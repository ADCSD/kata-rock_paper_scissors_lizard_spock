{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Kata Rock Paper Scissors Lizard Spock TDD Switch case Easy Descripci\u00f3n de la Kata Esta Kata est\u00e1 basada en el juego modificado que aparece en la serie The Big Bang Theory. Se trata del cl\u00e1sico juego Piedra, papel o tijera , pero modificado con dos nuevos movimientos para aumentar el n\u00famero de posibilidades en el juego. Es una Kata sencilla de implementar y que ofrece la posibilidad de refactorizar el switch statement que nos ir\u00e1 apareciendo a lo largo de la implementaci\u00f3n. Enunciado Las reglas son sencillas, al igual que el juego original, dos jugadores muestran a la vez un movimiento de entre 5 posibles (Piedra, Papel, Tijeras, Lagarto, Spock), si los movimientos son iguales el resultado de la partida es empate, pero si los movimientos se calcular\u00e1 la victoria en funci\u00f3n de las siguientes reglas. Reglas: Tijeras cortan el Papel Papel recubre la Piedra Piedra aplasta al Lagarto Lagarto envenena a Spock Spock rompe las Tijeras Tijeras decapitan al Lagarto Lagarto se come el Papel Papel desaprueba a Spock Spock vaporiza la Piedra Piedra aplasta Tijeras Se pide hacer un algoritmo que dados dos movimientos calcule cual ser\u00e1 el resultado de la partida. Consejos para desarrollo Haremos solo una tarea a la vez. Tenemos que aprender a trabajar de forma incremental. Para esta kata solo vamos a testear las entradas correctas. Por agilidad en la session. Llegaremos hasta donde nos de tiempo. No se trata de terminarlo, sino de aprender durante el proceso. Programaremos entre todos. No existe una soluci\u00f3n correcta y una incorrecta, se puede hacer de muchas formas. No te olvides de pasar los tests a cada cambio que se efectue del c\u00f3digo, para verificar que funciona todo correctamente y que no se ha roto nada m\u00e1s. Fuente La kata ha sido extraida de The Big Bang Theory Soluciones Todas las posibles soluciones las pod\u00e9is ver en el Github de ADCSD Original . Es el proyecto vac\u00edo original con el que empezar el ejercicio Kata-sesion . Es el proyecto tal y como qued\u00f3 despu\u00e9s de hacer una sesi\u00f3n de CodingDojo Solucion . Es el proyecto resuelto por completo que iremos viendo poco a poco en los siguientes cap\u00edtulos Licencias Las imagenes del tutorial han sido extraidas de Refactoring Guru .","title":"Introducci\u00f3n"},{"location":"#kata-rock-paper-scissors-lizard-spock","text":"TDD Switch case Easy","title":"Kata Rock Paper Scissors Lizard Spock"},{"location":"#descripcion-de-la-kata","text":"Esta Kata est\u00e1 basada en el juego modificado que aparece en la serie The Big Bang Theory. Se trata del cl\u00e1sico juego Piedra, papel o tijera , pero modificado con dos nuevos movimientos para aumentar el n\u00famero de posibilidades en el juego. Es una Kata sencilla de implementar y que ofrece la posibilidad de refactorizar el switch statement que nos ir\u00e1 apareciendo a lo largo de la implementaci\u00f3n.","title":"Descripci\u00f3n de la Kata"},{"location":"#enunciado","text":"Las reglas son sencillas, al igual que el juego original, dos jugadores muestran a la vez un movimiento de entre 5 posibles (Piedra, Papel, Tijeras, Lagarto, Spock), si los movimientos son iguales el resultado de la partida es empate, pero si los movimientos se calcular\u00e1 la victoria en funci\u00f3n de las siguientes reglas. Reglas: Tijeras cortan el Papel Papel recubre la Piedra Piedra aplasta al Lagarto Lagarto envenena a Spock Spock rompe las Tijeras Tijeras decapitan al Lagarto Lagarto se come el Papel Papel desaprueba a Spock Spock vaporiza la Piedra Piedra aplasta Tijeras Se pide hacer un algoritmo que dados dos movimientos calcule cual ser\u00e1 el resultado de la partida.","title":"Enunciado"},{"location":"#consejos-para-desarrollo","text":"Haremos solo una tarea a la vez. Tenemos que aprender a trabajar de forma incremental. Para esta kata solo vamos a testear las entradas correctas. Por agilidad en la session. Llegaremos hasta donde nos de tiempo. No se trata de terminarlo, sino de aprender durante el proceso. Programaremos entre todos. No existe una soluci\u00f3n correcta y una incorrecta, se puede hacer de muchas formas. No te olvides de pasar los tests a cada cambio que se efectue del c\u00f3digo, para verificar que funciona todo correctamente y que no se ha roto nada m\u00e1s.","title":"Consejos para desarrollo"},{"location":"#fuente","text":"La kata ha sido extraida de The Big Bang Theory","title":"Fuente"},{"location":"#soluciones","text":"Todas las posibles soluciones las pod\u00e9is ver en el Github de ADCSD Original . Es el proyecto vac\u00edo original con el que empezar el ejercicio Kata-sesion . Es el proyecto tal y como qued\u00f3 despu\u00e9s de hacer una sesi\u00f3n de CodingDojo Solucion . Es el proyecto resuelto por completo que iremos viendo poco a poco en los siguientes cap\u00edtulos","title":"Soluciones"},{"location":"#licencias","text":"Las imagenes del tutorial han sido extraidas de Refactoring Guru .","title":"Licencias"},{"location":"step0/","text":"Preparaci\u00f3n Proyecto original El proyecto original preparado para realizar la Kata se puede descargar del Github de ADCSD e importarlo directamente en el IDE de desarrollo. Debes descargar el proyecto que est\u00e1 dentro de la carpeta original . Estructura de proyecto Se trata de un proyecto escrito en Java con maven, que consta de dos clases vac\u00edas: TestRuleEngine y RuleEngine , y de dos enum: PlayMove y PlayResult . Aclaraciones Vamos a tratar de ver con mucho detalle y paso por paso la implementaci\u00f3n y su Refactor durante los primeros Requisitos , pero a medida que vayamos avanzando iremos resumiendo para que no se haga eterno el documento. Obviamente existen much\u00edsimas formas de implementar este ejercicio, lo que veremos a continuaci\u00f3n no es m\u00e1s que una de esas formas, ni mejor ni peor que cualquier otra. Es posible que tu tengas otra diferente, perfecto, tambi\u00e9n es v\u00e1lida. Adem\u00e1s, el nivel de Refactoring que vamos a ver en este ejercicio est\u00e1 pensado para explicar ciertas t\u00e9cnicas o acciones m\u00e1s habituales. Esto no quiere decir que siempre se deba llegar a este nivel, ni mucho menos, o que solo exista una forma de realizar el Refactoring . Al igual que las implementaciones, hay muchas formas de refactorizar, cada uno deber\u00eda quedarse en el nivel de refactorizaci\u00f3n con el que se sienta m\u00e1s c\u00f3modo. Debemos buscar un compromiso entre el tiempo dedicado y la facilidad de lectura que estamos dejando, pero sin obsesionarnos.","title":"Preparaci\u00f3n"},{"location":"step0/#preparacion","text":"","title":"Preparaci\u00f3n"},{"location":"step0/#proyecto-original","text":"El proyecto original preparado para realizar la Kata se puede descargar del Github de ADCSD e importarlo directamente en el IDE de desarrollo. Debes descargar el proyecto que est\u00e1 dentro de la carpeta original .","title":"Proyecto original"},{"location":"step0/#estructura-de-proyecto","text":"Se trata de un proyecto escrito en Java con maven, que consta de dos clases vac\u00edas: TestRuleEngine y RuleEngine , y de dos enum: PlayMove y PlayResult .","title":"Estructura de proyecto"},{"location":"step0/#aclaraciones","text":"Vamos a tratar de ver con mucho detalle y paso por paso la implementaci\u00f3n y su Refactor durante los primeros Requisitos , pero a medida que vayamos avanzando iremos resumiendo para que no se haga eterno el documento. Obviamente existen much\u00edsimas formas de implementar este ejercicio, lo que veremos a continuaci\u00f3n no es m\u00e1s que una de esas formas, ni mejor ni peor que cualquier otra. Es posible que tu tengas otra diferente, perfecto, tambi\u00e9n es v\u00e1lida. Adem\u00e1s, el nivel de Refactoring que vamos a ver en este ejercicio est\u00e1 pensado para explicar ciertas t\u00e9cnicas o acciones m\u00e1s habituales. Esto no quiere decir que siempre se deba llegar a este nivel, ni mucho menos, o que solo exista una forma de realizar el Refactoring . Al igual que las implementaciones, hay muchas formas de refactorizar, cada uno deber\u00eda quedarse en el nivel de refactorizaci\u00f3n con el que se sienta m\u00e1s c\u00f3modo. Debemos buscar un compromiso entre el tiempo dedicado y la facilidad de lectura que estamos dejando, pero sin obsesionarnos.","title":"Aclaraciones"},{"location":"step1/","text":"Desarrollo del requisito 1 Requisito Dos jugadas iguales deben devolver un empate Desarrollo Empezamos la codificaci\u00f3n Como siempre, en TDD, empezamos creando el test unitario que cubra el primer requisito. Vamos a crear un test que cubra todos los posibles empates del juego. Vamos a utilizar los enum que tenemos ya creados para mejorar la legibilidad. Para ello a\u00f1adimos un test: TestRuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 @Test public void equals_move_result_draw () { RuleEngine ruleEngine = new RuleEngine (); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . ROCK , PlayMove . ROCK )); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . PAPER , PlayMove . PAPER )); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . SCISSORS , PlayMove . SCISSORS )); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . LIZARD , PlayMove . LIZARD )); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . SPOCK , PlayMove . SPOCK )); } Recuerda Recuerda que los nombres de los tests deben ser descriptivos, para que no sea necesario leer el c\u00f3digo del test para saber lo que realiza. Con leer el nombre del m\u00e9todo deber\u00eda ser suficiente para saber lo que hace. Obviamente si ejecutamos el test, obtendremos un test fail en rojo ya que nuestro c\u00f3digo no cumple con lo esperado por el test. El siguiente paso en TDD es realizar la implementaci\u00f3n m\u00ednima que haga funcionar los tests. RuleEngine 1 2 3 4 5 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { return PlayResult . DRAW ; } La implementaci\u00f3n m\u00ednima que se me ocurre ahora mismo y que pasar\u00eda todos los tests actuales es esta. Ahora si ejecutamos, obtenemos una ejecuci\u00f3n correcta en verde. El siguiente paso paso en TDD ser\u00eda realizar el Refactoring . Aunque se podr\u00eda aplicar alguna acci\u00f3n, vamos a dejarlo pasar hasta tener algo m\u00e1s de c\u00f3digo, donde ya empecemos a detectar ciertos smells . Cuidado - Speculative Generality Uno de los smells m\u00e1s t\u00edpicos que solemos cometer todos es el de Speculative Generality . Este smell nos indica que estamos construyendo m\u00e1s c\u00f3digo fuente del estrictamente necesario. Esto nos pasa cuando nos estamos adelantando al futuro y estamos preparando el c\u00f3digo para \"por si acaso\" nos hace falta luego. Es un esfuerzo que muy a menudo podemos ahorrarnos ya que ese \"por si acaso\" a menudo nunca llega o cambia de aspecto . Resultado final Como de momento no vamos a hacer Refactor , el c\u00f3digo que tenemos deber\u00eda ser este: TestRuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class TestRuleEngine { @Test public void equals_move_result_draw () { RuleEngine ruleEngine = new RuleEngine (); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . ROCK , PlayMove . ROCK )); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . PAPER , PlayMove . PAPER )); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . SCISSORS , PlayMove . SCISSORS )); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . LIZARD , PlayMove . LIZARD )); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . SPOCK , PlayMove . SPOCK )); } } RuleEngine 1 2 3 4 5 6 7 8 9 public class RuleEngine { public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { return PlayResult . DRAW ; } }","title":"R1. Jugadas iguales, empate"},{"location":"step1/#desarrollo-del-requisito-1","text":"","title":"Desarrollo del requisito 1"},{"location":"step1/#requisito","text":"Dos jugadas iguales deben devolver un empate","title":"Requisito"},{"location":"step1/#desarrollo","text":"","title":"Desarrollo"},{"location":"step1/#empezamos-la-codificacion","text":"Como siempre, en TDD, empezamos creando el test unitario que cubra el primer requisito. Vamos a crear un test que cubra todos los posibles empates del juego. Vamos a utilizar los enum que tenemos ya creados para mejorar la legibilidad. Para ello a\u00f1adimos un test: TestRuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 @Test public void equals_move_result_draw () { RuleEngine ruleEngine = new RuleEngine (); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . ROCK , PlayMove . ROCK )); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . PAPER , PlayMove . PAPER )); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . SCISSORS , PlayMove . SCISSORS )); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . LIZARD , PlayMove . LIZARD )); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . SPOCK , PlayMove . SPOCK )); } Recuerda Recuerda que los nombres de los tests deben ser descriptivos, para que no sea necesario leer el c\u00f3digo del test para saber lo que realiza. Con leer el nombre del m\u00e9todo deber\u00eda ser suficiente para saber lo que hace. Obviamente si ejecutamos el test, obtendremos un test fail en rojo ya que nuestro c\u00f3digo no cumple con lo esperado por el test. El siguiente paso en TDD es realizar la implementaci\u00f3n m\u00ednima que haga funcionar los tests. RuleEngine 1 2 3 4 5 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { return PlayResult . DRAW ; } La implementaci\u00f3n m\u00ednima que se me ocurre ahora mismo y que pasar\u00eda todos los tests actuales es esta. Ahora si ejecutamos, obtenemos una ejecuci\u00f3n correcta en verde. El siguiente paso paso en TDD ser\u00eda realizar el Refactoring . Aunque se podr\u00eda aplicar alguna acci\u00f3n, vamos a dejarlo pasar hasta tener algo m\u00e1s de c\u00f3digo, donde ya empecemos a detectar ciertos smells . Cuidado - Speculative Generality Uno de los smells m\u00e1s t\u00edpicos que solemos cometer todos es el de Speculative Generality . Este smell nos indica que estamos construyendo m\u00e1s c\u00f3digo fuente del estrictamente necesario. Esto nos pasa cuando nos estamos adelantando al futuro y estamos preparando el c\u00f3digo para \"por si acaso\" nos hace falta luego. Es un esfuerzo que muy a menudo podemos ahorrarnos ya que ese \"por si acaso\" a menudo nunca llega o cambia de aspecto .","title":"Empezamos la codificaci\u00f3n"},{"location":"step1/#resultado-final","text":"Como de momento no vamos a hacer Refactor , el c\u00f3digo que tenemos deber\u00eda ser este: TestRuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class TestRuleEngine { @Test public void equals_move_result_draw () { RuleEngine ruleEngine = new RuleEngine (); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . ROCK , PlayMove . ROCK )); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . PAPER , PlayMove . PAPER )); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . SCISSORS , PlayMove . SCISSORS )); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . LIZARD , PlayMove . LIZARD )); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . SPOCK , PlayMove . SPOCK )); } } RuleEngine 1 2 3 4 5 6 7 8 9 public class RuleEngine { public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { return PlayResult . DRAW ; } }","title":"Resultado final"},{"location":"step10/","text":"Desarrollo del requisito 10 Requisito Spock vaporiza la piedra Desarrollo Nuevo requisito que podemos agrupar. TestRuleEngine 1 2 3 4 5 6 7 @Test public void spock_vaporizes_rock () { invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . ROCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . ROCK , PlayMove . SPOCK , PlayResult . WIN_PLAYER_TWO ); } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && ( moveTwo . equals ( PlayMove . PAPER ) || moveTwo . equals ( PlayMove . LIZARD ))) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && ( moveTwo . equals ( PlayMove . ROCK ) || moveTwo . equals ( PlayMove . SPOCK ))) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && moveTwo . equals ( PlayMove . LIZARD )) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && ( moveTwo . equals ( PlayMove . SPOCK ) || moveTwo . equals ( PlayMove . PAPER ))) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && ( moveTwo . equals ( PlayMove . SCISSORS ) || moveTwo . equals ( PlayMove . ROCK ))) return true ; return false ; } Vamos a por el \u00faltimo y cl\u00e1sico requisito.","title":"R10. Spock vaporiza Piedra"},{"location":"step10/#desarrollo-del-requisito-10","text":"","title":"Desarrollo del requisito 10"},{"location":"step10/#requisito","text":"Spock vaporiza la piedra","title":"Requisito"},{"location":"step10/#desarrollo","text":"Nuevo requisito que podemos agrupar. TestRuleEngine 1 2 3 4 5 6 7 @Test public void spock_vaporizes_rock () { invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . ROCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . ROCK , PlayMove . SPOCK , PlayResult . WIN_PLAYER_TWO ); } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && ( moveTwo . equals ( PlayMove . PAPER ) || moveTwo . equals ( PlayMove . LIZARD ))) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && ( moveTwo . equals ( PlayMove . ROCK ) || moveTwo . equals ( PlayMove . SPOCK ))) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && moveTwo . equals ( PlayMove . LIZARD )) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && ( moveTwo . equals ( PlayMove . SPOCK ) || moveTwo . equals ( PlayMove . PAPER ))) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && ( moveTwo . equals ( PlayMove . SCISSORS ) || moveTwo . equals ( PlayMove . ROCK ))) return true ; return false ; } Vamos a por el \u00faltimo y cl\u00e1sico requisito.","title":"Desarrollo"},{"location":"step11/","text":"Desarrollo del requisito 11 Requisito La piedra aplasta a las tijeras Desarrollo Nuevo requisito que podemos agrupar. TestRuleEngine 1 2 3 4 5 6 7 @Test public void rock_crushes_scissors () { invokeAndCheckResult ( PlayMove . ROCK , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . ROCK , PlayResult . WIN_PLAYER_TWO ); } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && ( moveTwo . equals ( PlayMove . PAPER ) || moveTwo . equals ( PlayMove . LIZARD ))) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && ( moveTwo . equals ( PlayMove . ROCK ) || moveTwo . equals ( PlayMove . SPOCK ))) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && ( moveTwo . equals ( PlayMove . LIZARD ) || moveTwo . equals ( PlayMove . SCISSORS ))) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && ( moveTwo . equals ( PlayMove . SPOCK ) || moveTwo . equals ( PlayMove . PAPER ))) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && moveTwo . equals ( PlayMove . SCISSORS )) return true ; return false ; } Resultado final Ya hemos terminado la implementaci\u00f3n y tenemos esto: TestRuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 public class TestRuleEngine { RuleEngine ruleEngine = new RuleEngine (); @Test public void equals_move_result_draw () { invokeAndCheckResult ( PlayMove . ROCK , PlayMove . ROCK , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . PAPER , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . SCISSORS , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . LIZARD , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . SPOCK , PlayResult . DRAW ); } @Test public void scissors_cuts_paper () { invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . PAPER , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_TWO ); } @Test public void paper_cover_rock () { invokeAndCheckResult ( PlayMove . PAPER , PlayMove . ROCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . ROCK , PlayMove . PAPER , PlayResult . WIN_PLAYER_TWO ); } @Test public void rock_crushes_lizard () { invokeAndCheckResult ( PlayMove . ROCK , PlayMove . LIZARD , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . ROCK , PlayResult . WIN_PLAYER_TWO ); } @Test public void lizard_poisons_spock () { invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . SPOCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . LIZARD , PlayResult . WIN_PLAYER_TWO ); } @Test public void spock_smashes_scissors () { invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . SPOCK , PlayResult . WIN_PLAYER_TWO ); } @Test public void scissors_decapitates_lizard () { invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . LIZARD , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_TWO ); } @Test public void lizard_eats_paper () { invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . PAPER , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . LIZARD , PlayResult . WIN_PLAYER_TWO ); } @Test public void paper_disproves_spock () { invokeAndCheckResult ( PlayMove . PAPER , PlayMove . SPOCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . PAPER , PlayResult . WIN_PLAYER_TWO ); } @Test public void spock_vaporizes_rock () { invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . ROCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . ROCK , PlayMove . SPOCK , PlayResult . WIN_PLAYER_TWO ); } @Test public void rock_crushes_scissors () { invokeAndCheckResult ( PlayMove . ROCK , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . ROCK , PlayResult . WIN_PLAYER_TWO ); } private void invokeAndCheckResult ( PlayMove playerOne , PlayMove playerTwo , PlayResult expectedResult ) { Assert . assertEquals ( expectedResult , this . ruleEngine . play ( playerOne , playerTwo )); } } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public class RuleEngine { public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( isPlayerOneWinner ( playerOne , playerTwo )) return PlayResult . WIN_PLAYER_ONE ; if ( isPlayerTwoWinner ( playerOne , playerTwo )) return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } private boolean isPlayerOneWinner ( PlayMove playerOne , PlayMove playerTwo ) { return isPlayWinner ( playerOne , playerTwo ); } private boolean isPlayerTwoWinner ( PlayMove playerOne , PlayMove playerTwo ) { return isPlayWinner ( playerTwo , playerOne ); } private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && ( moveTwo . equals ( PlayMove . PAPER ) || moveTwo . equals ( PlayMove . LIZARD ))) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && ( moveTwo . equals ( PlayMove . ROCK ) || moveTwo . equals ( PlayMove . SPOCK ))) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && ( moveTwo . equals ( PlayMove . LIZARD ) || moveTwo . equals ( PlayMove . SCISSORS ))) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && ( moveTwo . equals ( PlayMove . SPOCK ) || moveTwo . equals ( PlayMove . PAPER ))) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && ( moveTwo . equals ( PlayMove . SCISSORS ) || moveTwo . equals ( PlayMove . ROCK ))) return true ; return false ; } } Futuros pasos Aunque la clase y los m\u00e9todos sean cortos, el m\u00e9todo isPlayWinner sigue teniendo 5 condiciones if que adem\u00e1s son complejas porque tienen tres comparaciones cada una. Estamos ante el t\u00edpico smell que nos aparecer\u00e1 much\u00edsimas veces a lo largo de nuestra vida Switch Statement .","title":"R11. Piedra aplasta Tijeras"},{"location":"step11/#desarrollo-del-requisito-11","text":"","title":"Desarrollo del requisito 11"},{"location":"step11/#requisito","text":"La piedra aplasta a las tijeras","title":"Requisito"},{"location":"step11/#desarrollo","text":"Nuevo requisito que podemos agrupar. TestRuleEngine 1 2 3 4 5 6 7 @Test public void rock_crushes_scissors () { invokeAndCheckResult ( PlayMove . ROCK , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . ROCK , PlayResult . WIN_PLAYER_TWO ); } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && ( moveTwo . equals ( PlayMove . PAPER ) || moveTwo . equals ( PlayMove . LIZARD ))) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && ( moveTwo . equals ( PlayMove . ROCK ) || moveTwo . equals ( PlayMove . SPOCK ))) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && ( moveTwo . equals ( PlayMove . LIZARD ) || moveTwo . equals ( PlayMove . SCISSORS ))) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && ( moveTwo . equals ( PlayMove . SPOCK ) || moveTwo . equals ( PlayMove . PAPER ))) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && moveTwo . equals ( PlayMove . SCISSORS )) return true ; return false ; }","title":"Desarrollo"},{"location":"step11/#resultado-final","text":"Ya hemos terminado la implementaci\u00f3n y tenemos esto: TestRuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 public class TestRuleEngine { RuleEngine ruleEngine = new RuleEngine (); @Test public void equals_move_result_draw () { invokeAndCheckResult ( PlayMove . ROCK , PlayMove . ROCK , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . PAPER , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . SCISSORS , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . LIZARD , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . SPOCK , PlayResult . DRAW ); } @Test public void scissors_cuts_paper () { invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . PAPER , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_TWO ); } @Test public void paper_cover_rock () { invokeAndCheckResult ( PlayMove . PAPER , PlayMove . ROCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . ROCK , PlayMove . PAPER , PlayResult . WIN_PLAYER_TWO ); } @Test public void rock_crushes_lizard () { invokeAndCheckResult ( PlayMove . ROCK , PlayMove . LIZARD , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . ROCK , PlayResult . WIN_PLAYER_TWO ); } @Test public void lizard_poisons_spock () { invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . SPOCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . LIZARD , PlayResult . WIN_PLAYER_TWO ); } @Test public void spock_smashes_scissors () { invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . SPOCK , PlayResult . WIN_PLAYER_TWO ); } @Test public void scissors_decapitates_lizard () { invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . LIZARD , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_TWO ); } @Test public void lizard_eats_paper () { invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . PAPER , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . LIZARD , PlayResult . WIN_PLAYER_TWO ); } @Test public void paper_disproves_spock () { invokeAndCheckResult ( PlayMove . PAPER , PlayMove . SPOCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . PAPER , PlayResult . WIN_PLAYER_TWO ); } @Test public void spock_vaporizes_rock () { invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . ROCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . ROCK , PlayMove . SPOCK , PlayResult . WIN_PLAYER_TWO ); } @Test public void rock_crushes_scissors () { invokeAndCheckResult ( PlayMove . ROCK , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . ROCK , PlayResult . WIN_PLAYER_TWO ); } private void invokeAndCheckResult ( PlayMove playerOne , PlayMove playerTwo , PlayResult expectedResult ) { Assert . assertEquals ( expectedResult , this . ruleEngine . play ( playerOne , playerTwo )); } } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public class RuleEngine { public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( isPlayerOneWinner ( playerOne , playerTwo )) return PlayResult . WIN_PLAYER_ONE ; if ( isPlayerTwoWinner ( playerOne , playerTwo )) return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } private boolean isPlayerOneWinner ( PlayMove playerOne , PlayMove playerTwo ) { return isPlayWinner ( playerOne , playerTwo ); } private boolean isPlayerTwoWinner ( PlayMove playerOne , PlayMove playerTwo ) { return isPlayWinner ( playerTwo , playerOne ); } private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && ( moveTwo . equals ( PlayMove . PAPER ) || moveTwo . equals ( PlayMove . LIZARD ))) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && ( moveTwo . equals ( PlayMove . ROCK ) || moveTwo . equals ( PlayMove . SPOCK ))) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && ( moveTwo . equals ( PlayMove . LIZARD ) || moveTwo . equals ( PlayMove . SCISSORS ))) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && ( moveTwo . equals ( PlayMove . SPOCK ) || moveTwo . equals ( PlayMove . PAPER ))) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && ( moveTwo . equals ( PlayMove . SCISSORS ) || moveTwo . equals ( PlayMove . ROCK ))) return true ; return false ; } }","title":"Resultado final"},{"location":"step11/#futuros-pasos","text":"Aunque la clase y los m\u00e9todos sean cortos, el m\u00e9todo isPlayWinner sigue teniendo 5 condiciones if que adem\u00e1s son complejas porque tienen tres comparaciones cada una. Estamos ante el t\u00edpico smell que nos aparecer\u00e1 much\u00edsimas veces a lo largo de nuestra vida Switch Statement .","title":"Futuros pasos"},{"location":"step12/","text":"Code Smell: Switch Statement Casi todos nuestros algoritmos, tarde o temprano, van a hacer uso de operadores switch / if , y por tanto nos aparecer\u00e1n este tipo de problemas. Es muy f\u00e1cil de detectar si en nuestro c\u00f3digo observamos un conjunto de switch o if-else que se comporta como un grupo de acciones \u00fanico. Problema El problema que nos puede traer este operador es doble: Dificulta la lectura del c\u00f3digo ya que obliga al desarrollador a memorizar el stack de las clausulas anteriores. Suele ser frecuente que si tenemos un operador switch , ese operador est\u00e9 repartido en m\u00e1s sitios del c\u00f3digo y por tanto, a la hora de modificar una condici\u00f3n, deberemos acordarnos de modificarlo varias veces. Tratamiento Existen diferentes tratamientos dependiendo del tipo de condicional que tengamos, incluso a veces se pueden aplicar varios tratamientos a la vez. Depender\u00e1 mucho de la casu\u00edstica que se nos presente, a continuaci\u00f3n veremos las acciones m\u00e1s t\u00edpicas. Tip 1. Decompose Conditional Extract Method Extract Variable Magic Number \u00bfComo detectarlo? Se da cuando vemos un condicional que es complejo o tiene muchas condiciones aunque sean sencillas. Problema El problema que nos aparece es que mientras est\u00e1s ocupado averiguando lo que hace el c\u00f3digo de dentro del bloque, olvidas cual era la condici\u00f3n. Y mientras est\u00e1s ocupado averiguando cual era la condici\u00f3n, olvidas lo que hace el c\u00f3digo de dentro del bloque. Obliga al cerebro a releer varias veces el mismo c\u00f3digo hasta asimilarlo por completo. Por ejemplo: if ( date . before ( SUMMER_START ) || date . after ( SUMMER_END )) { charge = quantity * winterRate + winterServiceCharge ; } else { charge = quantity * summerRate ; } Soluci\u00f3n Una posible soluci\u00f3n es descomponer las partes complicadas del condicional y separarlo en m\u00e9todos diferentes: condici\u00f3n , then , else . Al extraer el c\u00f3digo a m\u00e9todos correctamente nombrados, le estamos dando un valor sem\u00e1ntico a las condiciones y por tanto facilitando su lectura. if ( isNotSummer ( date )) { charge = quantity * winterRate + winterServiceCharge ; } else { charge = quantity * summerRate ; } Tip 2. Use Guard Clauses Add return Add throws \u00bfComo detectarlo? Se da cuando vemos condicionales anidados que parecen simples y siguen un flujo de respuesta en bloque. Problema El problema que nos aparece es que al estar anidados, es muy dificil seguir el flujo normal de ejecuci\u00f3n. Obliga al cerebro a tener que volver atr\u00e1s muchas veces, para leer condiciones e identaciones de las clausulas. Por ejemplo: public double getPayAmount () { double result ; if ( isDead ) { result = deadAmount (); } else { if ( isSeparated ) { result = separatedAmount (); } else { if ( isRetired ) { result = retiredAmount (); } else { result = normalPayAmount (); } } } return result ; } Soluci\u00f3n Hay que identificar cuales son las clausulas que conducen a un punto terminal (generalmente con una excepci\u00f3n o una devoluci\u00f3n inmediata del valor). Una vez identificadas, se debe reorganizar el c\u00f3digo con el objetivo de aplanar la estructura de c\u00f3digo, e introducir un punto de return en las clausulas de guarda. public double getPayAmount () { if ( isDead ) { return deadAmount (); } if ( isSeparated ) { return separatedAmount (); } if ( isRetired ) { return retiredAmount (); } return normalPayAmount (); } Tip 3. Substitute Algorithm Maps Lists Functions \u00bfComo detectarlo? Se da cuando hay una algoritmia clara o una correlaci\u00f3n entre la condici\u00f3n y lo que hace el bloque de c\u00f3digo. Problema Las condiciones ya nos est\u00e1n diciendo claramente lo que va a hacer el c\u00f3digo. Hay una especie de duplicidad innecesaria. public String foundPerson ( String [] people ) { for ( int i = 0 ; i < people . length ; i ++ ) { if ( people [ i ] . equals ( \"Don\" )) { return \"Don\" ; } if ( people [ i ] . equals ( \"John\" )) { return \"John\" ; } if ( people [ i ] . equals ( \"Kent\" )) { return \"Kent\" ; } } return \"\" ; } Soluci\u00f3n Tal vez existe un algoritmo mucho m\u00e1s simple y eficiente que pueda realizar esa misma funcionalidad. A veces tambi\u00e9n se puede sustituir por List , Map o por librer\u00edas o frameworks que ya realizan esa funcionalidad. private List candidates = Arrays . asList ( new String [] { \"Don\" , \"John\" , \"Kent\" }); public String foundPerson ( String [] people ) { for ( int i = 0 ; i < people . length ; i ++ ) { if ( candidates . contains ( people [ i ] )) { return people [ i ] ; } } return \"\" ; } Tip 4. Use Polymorphism State Pattern Strategy Pattern \u00bfComo detectarlo? Cuando tenemos que cada una de las condiciones realizan una acci\u00f3n diferente dependiendo del tipo de condici\u00f3n. Adem\u00e1s, puede ser que esta misma estructura la tengamos varias veces repetidas en el c\u00f3digo. Problema Si aparecen nuevos tipos de condiciones debemos crear nuevas acciones y recordar que debemos modificar todas las estructuras condionales que tengamos iguales. class Bird { public double getSpeed () { switch ( type ) { case EUROPEAN : return getBaseSpeed (); case AFRICAN : return getBaseSpeed () - getLoadFactor () * numberOfCoconuts ; case NORWEGIAN_BLUE : return ( isNailed ) ? 0 : getBaseSpeed ( voltage ); } throw new RuntimeException ( \"Should be unreachable\" ); } public String getColor () { switch ( type ) { case EUROPEAN : return BROWNISH ; case AFRICAN : return ELECTRIC_YELLOW ; case NORWEGIAN_BLUE : return BLUE ; } throw new RuntimeException ( \"Should be unreachable\" ); } public double getSize () { ... } } Soluci\u00f3n Utiliando la herencia se pueden crear subclases que implementen sus propio comportamiento, mientras que en la clase base implementaremos el comportamiento estandar. Se puede implementar el State Pattern o el Strategy Pattern . Hay que crear una clase base con el caso general y luego una subclase con cada una de las condiciones del condicional. Luego hay que implementar los m\u00e9todos necesarios en cada subclase y mover el c\u00f3digo del condicional a la subclase. Si aparecen nuevos tipos solo hay que implementar una nueva subclase con su comportamiento. class Bird { public double getSpeed () { throw new RuntimeException ( \"Should be unreachable\" ); } public String getColor () { throw new RuntimeException ( \"Should be unreachable\" ); } public double getSize () { ... } } class European extends Bird { public double getSpeed () { return getBaseSpeed (); } public String getColor () { return BROWNISH ; } public double getSize () { ... } } class African extends Bird { public double getSpeed () { return getBaseSpeed () - getLoadFactor () * numberOfCoconuts ; } public String getColor () { return ELECTRIC_YELLOW ; } public double getSize () { ... } } class NorwegianBlue extends Bird { public double getSpeed () { return getBaseSpeed (); } public String getColor () { return ( isNailed ) ? 0 : getBaseSpeed ( voltage ); } public double getSize () { ... } } Resultado Hemos conseguido tener el c\u00f3digo m\u00e1s organizado, m\u00e1s legible y por tanto m\u00e1s f\u00e1cil de entender y modificar. Adem\u00e1s, es muy probable que hayamos disminuido el c\u00f3digo duplicado. Excepciones Aunque es buena pr\u00e1ctica eliminar este tipo de smells hay alguna excepci\u00f3n donde no est\u00e1 aconsejado hacerlo: Cuando un switch realiza acciones muy simples y no se repite en el c\u00f3digo, no es necesario refactorizar en profundidad. A menudo, los operadores switch se utilizan en los patrones Factory Method o Abstract Factory para seleccionar la clase a crear. Licencia Las imagenes del tutorial han sido extraidas de Refactoring Guru .","title":"CodeSmell. Switch Statement"},{"location":"step12/#code-smell-switch-statement","text":"Casi todos nuestros algoritmos, tarde o temprano, van a hacer uso de operadores switch / if , y por tanto nos aparecer\u00e1n este tipo de problemas. Es muy f\u00e1cil de detectar si en nuestro c\u00f3digo observamos un conjunto de switch o if-else que se comporta como un grupo de acciones \u00fanico.","title":"Code Smell: Switch Statement"},{"location":"step12/#problema","text":"El problema que nos puede traer este operador es doble: Dificulta la lectura del c\u00f3digo ya que obliga al desarrollador a memorizar el stack de las clausulas anteriores. Suele ser frecuente que si tenemos un operador switch , ese operador est\u00e9 repartido en m\u00e1s sitios del c\u00f3digo y por tanto, a la hora de modificar una condici\u00f3n, deberemos acordarnos de modificarlo varias veces.","title":"Problema"},{"location":"step12/#tratamiento","text":"Existen diferentes tratamientos dependiendo del tipo de condicional que tengamos, incluso a veces se pueden aplicar varios tratamientos a la vez. Depender\u00e1 mucho de la casu\u00edstica que se nos presente, a continuaci\u00f3n veremos las acciones m\u00e1s t\u00edpicas.","title":"Tratamiento"},{"location":"step12/#tip-1-decompose-conditional","text":"Extract Method Extract Variable Magic Number","title":"Tip 1. Decompose Conditional"},{"location":"step12/#como-detectarlo","text":"Se da cuando vemos un condicional que es complejo o tiene muchas condiciones aunque sean sencillas.","title":"\u00bfComo detectarlo?"},{"location":"step12/#problema_1","text":"El problema que nos aparece es que mientras est\u00e1s ocupado averiguando lo que hace el c\u00f3digo de dentro del bloque, olvidas cual era la condici\u00f3n. Y mientras est\u00e1s ocupado averiguando cual era la condici\u00f3n, olvidas lo que hace el c\u00f3digo de dentro del bloque. Obliga al cerebro a releer varias veces el mismo c\u00f3digo hasta asimilarlo por completo. Por ejemplo: if ( date . before ( SUMMER_START ) || date . after ( SUMMER_END )) { charge = quantity * winterRate + winterServiceCharge ; } else { charge = quantity * summerRate ; }","title":"Problema"},{"location":"step12/#solucion","text":"Una posible soluci\u00f3n es descomponer las partes complicadas del condicional y separarlo en m\u00e9todos diferentes: condici\u00f3n , then , else . Al extraer el c\u00f3digo a m\u00e9todos correctamente nombrados, le estamos dando un valor sem\u00e1ntico a las condiciones y por tanto facilitando su lectura. if ( isNotSummer ( date )) { charge = quantity * winterRate + winterServiceCharge ; } else { charge = quantity * summerRate ; }","title":"Soluci\u00f3n"},{"location":"step12/#tip-2-use-guard-clauses","text":"Add return Add throws","title":"Tip 2. Use Guard Clauses"},{"location":"step12/#como-detectarlo_1","text":"Se da cuando vemos condicionales anidados que parecen simples y siguen un flujo de respuesta en bloque.","title":"\u00bfComo detectarlo?"},{"location":"step12/#problema_2","text":"El problema que nos aparece es que al estar anidados, es muy dificil seguir el flujo normal de ejecuci\u00f3n. Obliga al cerebro a tener que volver atr\u00e1s muchas veces, para leer condiciones e identaciones de las clausulas. Por ejemplo: public double getPayAmount () { double result ; if ( isDead ) { result = deadAmount (); } else { if ( isSeparated ) { result = separatedAmount (); } else { if ( isRetired ) { result = retiredAmount (); } else { result = normalPayAmount (); } } } return result ; }","title":"Problema"},{"location":"step12/#solucion_1","text":"Hay que identificar cuales son las clausulas que conducen a un punto terminal (generalmente con una excepci\u00f3n o una devoluci\u00f3n inmediata del valor). Una vez identificadas, se debe reorganizar el c\u00f3digo con el objetivo de aplanar la estructura de c\u00f3digo, e introducir un punto de return en las clausulas de guarda. public double getPayAmount () { if ( isDead ) { return deadAmount (); } if ( isSeparated ) { return separatedAmount (); } if ( isRetired ) { return retiredAmount (); } return normalPayAmount (); }","title":"Soluci\u00f3n"},{"location":"step12/#tip-3-substitute-algorithm","text":"Maps Lists Functions","title":"Tip 3. Substitute Algorithm"},{"location":"step12/#como-detectarlo_2","text":"Se da cuando hay una algoritmia clara o una correlaci\u00f3n entre la condici\u00f3n y lo que hace el bloque de c\u00f3digo.","title":"\u00bfComo detectarlo?"},{"location":"step12/#problema_3","text":"Las condiciones ya nos est\u00e1n diciendo claramente lo que va a hacer el c\u00f3digo. Hay una especie de duplicidad innecesaria. public String foundPerson ( String [] people ) { for ( int i = 0 ; i < people . length ; i ++ ) { if ( people [ i ] . equals ( \"Don\" )) { return \"Don\" ; } if ( people [ i ] . equals ( \"John\" )) { return \"John\" ; } if ( people [ i ] . equals ( \"Kent\" )) { return \"Kent\" ; } } return \"\" ; }","title":"Problema"},{"location":"step12/#solucion_2","text":"Tal vez existe un algoritmo mucho m\u00e1s simple y eficiente que pueda realizar esa misma funcionalidad. A veces tambi\u00e9n se puede sustituir por List , Map o por librer\u00edas o frameworks que ya realizan esa funcionalidad. private List candidates = Arrays . asList ( new String [] { \"Don\" , \"John\" , \"Kent\" }); public String foundPerson ( String [] people ) { for ( int i = 0 ; i < people . length ; i ++ ) { if ( candidates . contains ( people [ i ] )) { return people [ i ] ; } } return \"\" ; }","title":"Soluci\u00f3n"},{"location":"step12/#tip-4-use-polymorphism","text":"State Pattern Strategy Pattern","title":"Tip 4. Use Polymorphism"},{"location":"step12/#como-detectarlo_3","text":"Cuando tenemos que cada una de las condiciones realizan una acci\u00f3n diferente dependiendo del tipo de condici\u00f3n. Adem\u00e1s, puede ser que esta misma estructura la tengamos varias veces repetidas en el c\u00f3digo.","title":"\u00bfComo detectarlo?"},{"location":"step12/#problema_4","text":"Si aparecen nuevos tipos de condiciones debemos crear nuevas acciones y recordar que debemos modificar todas las estructuras condionales que tengamos iguales. class Bird { public double getSpeed () { switch ( type ) { case EUROPEAN : return getBaseSpeed (); case AFRICAN : return getBaseSpeed () - getLoadFactor () * numberOfCoconuts ; case NORWEGIAN_BLUE : return ( isNailed ) ? 0 : getBaseSpeed ( voltage ); } throw new RuntimeException ( \"Should be unreachable\" ); } public String getColor () { switch ( type ) { case EUROPEAN : return BROWNISH ; case AFRICAN : return ELECTRIC_YELLOW ; case NORWEGIAN_BLUE : return BLUE ; } throw new RuntimeException ( \"Should be unreachable\" ); } public double getSize () { ... } }","title":"Problema"},{"location":"step12/#solucion_3","text":"Utiliando la herencia se pueden crear subclases que implementen sus propio comportamiento, mientras que en la clase base implementaremos el comportamiento estandar. Se puede implementar el State Pattern o el Strategy Pattern . Hay que crear una clase base con el caso general y luego una subclase con cada una de las condiciones del condicional. Luego hay que implementar los m\u00e9todos necesarios en cada subclase y mover el c\u00f3digo del condicional a la subclase. Si aparecen nuevos tipos solo hay que implementar una nueva subclase con su comportamiento. class Bird { public double getSpeed () { throw new RuntimeException ( \"Should be unreachable\" ); } public String getColor () { throw new RuntimeException ( \"Should be unreachable\" ); } public double getSize () { ... } } class European extends Bird { public double getSpeed () { return getBaseSpeed (); } public String getColor () { return BROWNISH ; } public double getSize () { ... } } class African extends Bird { public double getSpeed () { return getBaseSpeed () - getLoadFactor () * numberOfCoconuts ; } public String getColor () { return ELECTRIC_YELLOW ; } public double getSize () { ... } } class NorwegianBlue extends Bird { public double getSpeed () { return getBaseSpeed (); } public String getColor () { return ( isNailed ) ? 0 : getBaseSpeed ( voltage ); } public double getSize () { ... } }","title":"Soluci\u00f3n"},{"location":"step12/#resultado","text":"Hemos conseguido tener el c\u00f3digo m\u00e1s organizado, m\u00e1s legible y por tanto m\u00e1s f\u00e1cil de entender y modificar. Adem\u00e1s, es muy probable que hayamos disminuido el c\u00f3digo duplicado.","title":"Resultado"},{"location":"step12/#excepciones","text":"Aunque es buena pr\u00e1ctica eliminar este tipo de smells hay alguna excepci\u00f3n donde no est\u00e1 aconsejado hacerlo: Cuando un switch realiza acciones muy simples y no se repite en el c\u00f3digo, no es necesario refactorizar en profundidad. A menudo, los operadores switch se utilizan en los patrones Factory Method o Abstract Factory para seleccionar la clase a crear.","title":"Excepciones"},{"location":"step12/#licencia","text":"Las imagenes del tutorial han sido extraidas de Refactoring Guru .","title":"Licencia"},{"location":"step13/","text":"Refactor del Switch Statement en nuestra kata Ahora que ya hemos visto que acciones se pueden realizar para mitigar el code smell vamos a aplicarlas sobre la implementaci\u00f3n que tenemos de la kata. C\u00f3digo de origen Recordemos que nuestro c\u00f3digo deber\u00eda estar as\u00ed: TestRuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 public class TestRuleEngine { RuleEngine ruleEngine = new RuleEngine (); @Test public void equals_move_result_draw () { invokeAndCheckResult ( PlayMove . ROCK , PlayMove . ROCK , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . PAPER , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . SCISSORS , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . LIZARD , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . SPOCK , PlayResult . DRAW ); } @Test public void scissors_cuts_paper () { invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . PAPER , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_TWO ); } @Test public void paper_cover_rock () { invokeAndCheckResult ( PlayMove . PAPER , PlayMove . ROCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . ROCK , PlayMove . PAPER , PlayResult . WIN_PLAYER_TWO ); } @Test public void rock_crushes_lizard () { invokeAndCheckResult ( PlayMove . ROCK , PlayMove . LIZARD , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . ROCK , PlayResult . WIN_PLAYER_TWO ); } @Test public void lizard_poisons_spock () { invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . SPOCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . LIZARD , PlayResult . WIN_PLAYER_TWO ); } @Test public void spock_smashes_scissors () { invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . SPOCK , PlayResult . WIN_PLAYER_TWO ); } @Test public void scissors_decapitates_lizard () { invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . LIZARD , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_TWO ); } @Test public void lizard_eats_paper () { invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . PAPER , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . LIZARD , PlayResult . WIN_PLAYER_TWO ); } @Test public void paper_disproves_spock () { invokeAndCheckResult ( PlayMove . PAPER , PlayMove . SPOCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . PAPER , PlayResult . WIN_PLAYER_TWO ); } @Test public void spock_vaporizes_rock () { invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . ROCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . ROCK , PlayMove . SPOCK , PlayResult . WIN_PLAYER_TWO ); } @Test public void rock_crushes_scissors () { invokeAndCheckResult ( PlayMove . ROCK , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . ROCK , PlayResult . WIN_PLAYER_TWO ); } private void invokeAndCheckResult ( PlayMove playerOne , PlayMove playerTwo , PlayResult expectedResult ) { Assert . assertEquals ( expectedResult , this . ruleEngine . play ( playerOne , playerTwo )); } } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public class RuleEngine { public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( isPlayerOneWinner ( playerOne , playerTwo )) return PlayResult . WIN_PLAYER_ONE ; if ( isPlayerTwoWinner ( playerOne , playerTwo )) return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } private boolean isPlayerOneWinner ( PlayMove playerOne , PlayMove playerTwo ) { return isPlayWinner ( playerOne , playerTwo ); } private boolean isPlayerTwoWinner ( PlayMove playerOne , PlayMove playerTwo ) { return isPlayWinner ( playerTwo , playerOne ); } private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && ( moveTwo . equals ( PlayMove . PAPER ) || moveTwo . equals ( PlayMove . LIZARD ))) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && ( moveTwo . equals ( PlayMove . ROCK ) || moveTwo . equals ( PlayMove . SPOCK ))) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && ( moveTwo . equals ( PlayMove . LIZARD ) || moveTwo . equals ( PlayMove . SCISSORS ))) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && ( moveTwo . equals ( PlayMove . SPOCK ) || moveTwo . equals ( PlayMove . PAPER ))) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && ( moveTwo . equals ( PlayMove . SCISSORS ) || moveTwo . equals ( PlayMove . ROCK ))) return true ; return false ; } } Tip 1. Decompose Conditional Extract Method Extract Variable Magic Number Esta acci\u00f3n trata de darle un valor m\u00e1s sem\u00e1ntico a las condiciones de nuestro if-else . As\u00ed el cebrero no tiene que almacenar las condiciones como tal sino un texto m\u00e1s sem\u00e1ntico. Original 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && ( moveTwo . equals ( PlayMove . PAPER ) || moveTwo . equals ( PlayMove . LIZARD ))) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && ( moveTwo . equals ( PlayMove . ROCK ) || moveTwo . equals ( PlayMove . SPOCK ))) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && ( moveTwo . equals ( PlayMove . LIZARD ) || moveTwo . equals ( PlayMove . SCISSORS ))) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && ( moveTwo . equals ( PlayMove . SPOCK ) || moveTwo . equals ( PlayMove . PAPER ))) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && ( moveTwo . equals ( PlayMove . SCISSORS ) || moveTwo . equals ( PlayMove . ROCK ))) return true ; return false ; } Refactorizado 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && isScissorsWin ( moveTwo )) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && isPaperWin ( moveTwo )) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && isRockWin ( moveTwo )) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && isLizardWin ( moveTwo )) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && isSpockWin ( moveTwo )) return true ; return false ; } Tip 2. Use Guard Clauses Add return Add throws En realidad esto ya lo hab\u00edamos hecho en la refactorizaci\u00f3n del Requisito 2. Tijeras cortan Papel . En lugar de tener clausulas if-else lo hemos simplificado con puntos de return. Original 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { PlayResult result = null ; if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) { result = PlayResult . WIN_PLAYER_ONE ; } else if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) { result = PlayResult . WIN_PLAYER_TWO ; } else { result = PlayResult . DRAW ; } return result ; } Refactorizado 1 2 3 4 5 6 7 8 9 10 11 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } Tip 3. Substitute Algorithm Maps Lists Functions En este caso, al tratarse de una condiciones simples podemos extraer esa correlaci\u00f3n a una estructura de datos. Tenemos que cada movimiento gana a un conjunto de movimientos, es decir, cada PlayMove tiene asociado un List<PlayMove> sobre los que gana. Podr\u00edamos tener un Map donde para cada PlayMove almacenemos su conjunto de sus PlayMove sobre los que gana. Original 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && ( moveTwo . equals ( PlayMove . PAPER ) || moveTwo . equals ( PlayMove . LIZARD ))) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && ( moveTwo . equals ( PlayMove . ROCK ) || moveTwo . equals ( PlayMove . SPOCK ))) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && ( moveTwo . equals ( PlayMove . LIZARD ) || moveTwo . equals ( PlayMove . SCISSORS ))) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && ( moveTwo . equals ( PlayMove . SPOCK ) || moveTwo . equals ( PlayMove . PAPER ))) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && ( moveTwo . equals ( PlayMove . SCISSORS ) || moveTwo . equals ( PlayMove . ROCK ))) return true ; return false ; } Refactorizado 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Map < PlayMove , List < PlayMove >> WIN_MOVES = new HashMap < PlayMove , List < PlayMove >> () { { put ( PlayMove . SCISSORS , Arrays . asList ( new PlayMove [] { PlayMove . PAPER , PlayMove . LIZARD })); put ( PlayMove . PAPER , Arrays . asList ( new PlayMove [] { PlayMove . ROCK , PlayMove . SPOCK })); put ( PlayMove . ROCK , Arrays . asList ( new PlayMove [] { PlayMove . LIZARD , PlayMove . SCISSORS })); put ( PlayMove . LIZARD , Arrays . asList ( new PlayMove [] { PlayMove . SPOCK , PlayMove . PAPER })); put ( PlayMove . SPOCK , Arrays . asList ( new PlayMove [] { PlayMove . SCISSORS , PlayMove . ROCK })); } }; private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { return this . WIN_MOVES . get ( moveOne ). contains ( moveTwo ); } Tip 4. Use Polymorphism State Pattern Strategy Pattern Tambi\u00e9n se puede utilizar patrones de dise\u00f1o como el State Pattern y Strategy Pattern y hacer uso de la herencia. Para ello, crear\u00edamos una clase Base abstracta que tuviera el m\u00e9todo que comprueba si un movimiento gana a otro. Luego crear\u00edamos tantas especificaciones de esa clase como diferentes movimientos existen en el juego. Si aparecen nuevas reglas o movimientos solo hay que crear o modificar las especificaciones. Con subclases Original 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && ( moveTwo . equals ( PlayMove . PAPER ) || moveTwo . equals ( PlayMove . LIZARD ))) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && ( moveTwo . equals ( PlayMove . ROCK ) || moveTwo . equals ( PlayMove . SPOCK ))) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && ( moveTwo . equals ( PlayMove . LIZARD ) || moveTwo . equals ( PlayMove . SCISSORS ))) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && ( moveTwo . equals ( PlayMove . SPOCK ) || moveTwo . equals ( PlayMove . PAPER ))) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && ( moveTwo . equals ( PlayMove . SCISSORS ) || moveTwo . equals ( PlayMove . ROCK ))) return true ; return false ; } Refactorizado 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 public abstract class PlayMove { public static PlayMove ROCK = new MoveRock (); public static PlayMove PAPER = new MovePaper (); public static PlayMove SCISSORS = new MoveScissors (); public static PlayMove LIZARD = new MoveLizard (); public static PlayMove SPOCK = new MoveSpock (); abstract boolean isPlayWinner ( PlayMove move ); } public class MoveRock extends PlayMove { @Override boolean isPlayWinner ( PlayMove move ) { return move . equals ( PlayMove . LIZARD ) || move . equals ( PlayMove . SCISSORS ); } } public class MovePaper extends PlayMove { @Override boolean isPlayWinner ( PlayMove move ) { return move . equals ( PlayMove . ROCK ) || move . equals ( PlayMove . SPOCK ); } } public class MoveScissors extends PlayMove { @Override boolean isPlayWinner ( PlayMove move ) { return move . equals ( PlayMove . PAPER ) || move . equals ( PlayMove . LIZARD ); } } public class MoveLizard extends PlayMove { @Override boolean isPlayWinner ( PlayMove move ) { return move . equals ( PlayMove . SPOCK ) || move . equals ( PlayMove . PAPER ); } } public class MoveSpock extends PlayMove { @Override boolean isPlayWinner ( PlayMove move ) { return move . equals ( PlayMove . SCISSORS ) || move . equals ( PlayMove . ROCK ); } } public class RuleEngine { ... private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { return moveOne . isPlayWinner ( moveTwo ); } ... } Con Enums Incluso esto tambi\u00e9n podr\u00eda implementarse con los enum ya que permiten implementar c\u00f3digo dentro del enum . public enum PlayMove { ROCK { @Override boolean isPlayWinner ( PlayMove move ) { return move . equals ( PlayMove . LIZARD ) || move . equals ( PlayMove . SCISSORS ); } }, PAPER { @Override boolean isPlayWinner ( PlayMove move ) { return move . equals ( PlayMove . ROCK ) || move . equals ( PlayMove . SPOCK ); } }, SCISSORS { @Override boolean isPlayWinner ( PlayMove move ) { return move . equals ( PlayMove . PAPER ) || move . equals ( PlayMove . LIZARD ); } }, LIZARD { @Override boolean isPlayWinner ( PlayMove move ) { return move . equals ( PlayMove . SPOCK ) || move . equals ( PlayMove . PAPER ); } }, SPOCK { @Override boolean isPlayWinner ( PlayMove move ) { return move . equals ( PlayMove . SCISSORS ) || move . equals ( PlayMove . ROCK ); } }; abstract boolean isPlayWinner ( PlayMove move ); } public class RuleEngine { ... private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { return moveOne . isPlayWinner ( moveTwo ); } ... }","title":"Refactor Switch Statement"},{"location":"step13/#refactor-del-switch-statement-en-nuestra-kata","text":"Ahora que ya hemos visto que acciones se pueden realizar para mitigar el code smell vamos a aplicarlas sobre la implementaci\u00f3n que tenemos de la kata.","title":"Refactor del Switch Statement en nuestra kata"},{"location":"step13/#codigo-de-origen","text":"Recordemos que nuestro c\u00f3digo deber\u00eda estar as\u00ed: TestRuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 public class TestRuleEngine { RuleEngine ruleEngine = new RuleEngine (); @Test public void equals_move_result_draw () { invokeAndCheckResult ( PlayMove . ROCK , PlayMove . ROCK , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . PAPER , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . SCISSORS , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . LIZARD , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . SPOCK , PlayResult . DRAW ); } @Test public void scissors_cuts_paper () { invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . PAPER , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_TWO ); } @Test public void paper_cover_rock () { invokeAndCheckResult ( PlayMove . PAPER , PlayMove . ROCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . ROCK , PlayMove . PAPER , PlayResult . WIN_PLAYER_TWO ); } @Test public void rock_crushes_lizard () { invokeAndCheckResult ( PlayMove . ROCK , PlayMove . LIZARD , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . ROCK , PlayResult . WIN_PLAYER_TWO ); } @Test public void lizard_poisons_spock () { invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . SPOCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . LIZARD , PlayResult . WIN_PLAYER_TWO ); } @Test public void spock_smashes_scissors () { invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . SPOCK , PlayResult . WIN_PLAYER_TWO ); } @Test public void scissors_decapitates_lizard () { invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . LIZARD , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_TWO ); } @Test public void lizard_eats_paper () { invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . PAPER , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . LIZARD , PlayResult . WIN_PLAYER_TWO ); } @Test public void paper_disproves_spock () { invokeAndCheckResult ( PlayMove . PAPER , PlayMove . SPOCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . PAPER , PlayResult . WIN_PLAYER_TWO ); } @Test public void spock_vaporizes_rock () { invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . ROCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . ROCK , PlayMove . SPOCK , PlayResult . WIN_PLAYER_TWO ); } @Test public void rock_crushes_scissors () { invokeAndCheckResult ( PlayMove . ROCK , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . ROCK , PlayResult . WIN_PLAYER_TWO ); } private void invokeAndCheckResult ( PlayMove playerOne , PlayMove playerTwo , PlayResult expectedResult ) { Assert . assertEquals ( expectedResult , this . ruleEngine . play ( playerOne , playerTwo )); } } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public class RuleEngine { public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( isPlayerOneWinner ( playerOne , playerTwo )) return PlayResult . WIN_PLAYER_ONE ; if ( isPlayerTwoWinner ( playerOne , playerTwo )) return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } private boolean isPlayerOneWinner ( PlayMove playerOne , PlayMove playerTwo ) { return isPlayWinner ( playerOne , playerTwo ); } private boolean isPlayerTwoWinner ( PlayMove playerOne , PlayMove playerTwo ) { return isPlayWinner ( playerTwo , playerOne ); } private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && ( moveTwo . equals ( PlayMove . PAPER ) || moveTwo . equals ( PlayMove . LIZARD ))) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && ( moveTwo . equals ( PlayMove . ROCK ) || moveTwo . equals ( PlayMove . SPOCK ))) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && ( moveTwo . equals ( PlayMove . LIZARD ) || moveTwo . equals ( PlayMove . SCISSORS ))) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && ( moveTwo . equals ( PlayMove . SPOCK ) || moveTwo . equals ( PlayMove . PAPER ))) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && ( moveTwo . equals ( PlayMove . SCISSORS ) || moveTwo . equals ( PlayMove . ROCK ))) return true ; return false ; } }","title":"C\u00f3digo de origen"},{"location":"step13/#tip-1-decompose-conditional","text":"Extract Method Extract Variable Magic Number Esta acci\u00f3n trata de darle un valor m\u00e1s sem\u00e1ntico a las condiciones de nuestro if-else . As\u00ed el cebrero no tiene que almacenar las condiciones como tal sino un texto m\u00e1s sem\u00e1ntico. Original 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && ( moveTwo . equals ( PlayMove . PAPER ) || moveTwo . equals ( PlayMove . LIZARD ))) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && ( moveTwo . equals ( PlayMove . ROCK ) || moveTwo . equals ( PlayMove . SPOCK ))) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && ( moveTwo . equals ( PlayMove . LIZARD ) || moveTwo . equals ( PlayMove . SCISSORS ))) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && ( moveTwo . equals ( PlayMove . SPOCK ) || moveTwo . equals ( PlayMove . PAPER ))) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && ( moveTwo . equals ( PlayMove . SCISSORS ) || moveTwo . equals ( PlayMove . ROCK ))) return true ; return false ; } Refactorizado 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && isScissorsWin ( moveTwo )) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && isPaperWin ( moveTwo )) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && isRockWin ( moveTwo )) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && isLizardWin ( moveTwo )) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && isSpockWin ( moveTwo )) return true ; return false ; }","title":"Tip 1. Decompose Conditional"},{"location":"step13/#tip-2-use-guard-clauses","text":"Add return Add throws En realidad esto ya lo hab\u00edamos hecho en la refactorizaci\u00f3n del Requisito 2. Tijeras cortan Papel . En lugar de tener clausulas if-else lo hemos simplificado con puntos de return. Original 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { PlayResult result = null ; if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) { result = PlayResult . WIN_PLAYER_ONE ; } else if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) { result = PlayResult . WIN_PLAYER_TWO ; } else { result = PlayResult . DRAW ; } return result ; } Refactorizado 1 2 3 4 5 6 7 8 9 10 11 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; }","title":"Tip 2. Use Guard Clauses"},{"location":"step13/#tip-3-substitute-algorithm","text":"Maps Lists Functions En este caso, al tratarse de una condiciones simples podemos extraer esa correlaci\u00f3n a una estructura de datos. Tenemos que cada movimiento gana a un conjunto de movimientos, es decir, cada PlayMove tiene asociado un List<PlayMove> sobre los que gana. Podr\u00edamos tener un Map donde para cada PlayMove almacenemos su conjunto de sus PlayMove sobre los que gana. Original 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && ( moveTwo . equals ( PlayMove . PAPER ) || moveTwo . equals ( PlayMove . LIZARD ))) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && ( moveTwo . equals ( PlayMove . ROCK ) || moveTwo . equals ( PlayMove . SPOCK ))) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && ( moveTwo . equals ( PlayMove . LIZARD ) || moveTwo . equals ( PlayMove . SCISSORS ))) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && ( moveTwo . equals ( PlayMove . SPOCK ) || moveTwo . equals ( PlayMove . PAPER ))) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && ( moveTwo . equals ( PlayMove . SCISSORS ) || moveTwo . equals ( PlayMove . ROCK ))) return true ; return false ; } Refactorizado 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Map < PlayMove , List < PlayMove >> WIN_MOVES = new HashMap < PlayMove , List < PlayMove >> () { { put ( PlayMove . SCISSORS , Arrays . asList ( new PlayMove [] { PlayMove . PAPER , PlayMove . LIZARD })); put ( PlayMove . PAPER , Arrays . asList ( new PlayMove [] { PlayMove . ROCK , PlayMove . SPOCK })); put ( PlayMove . ROCK , Arrays . asList ( new PlayMove [] { PlayMove . LIZARD , PlayMove . SCISSORS })); put ( PlayMove . LIZARD , Arrays . asList ( new PlayMove [] { PlayMove . SPOCK , PlayMove . PAPER })); put ( PlayMove . SPOCK , Arrays . asList ( new PlayMove [] { PlayMove . SCISSORS , PlayMove . ROCK })); } }; private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { return this . WIN_MOVES . get ( moveOne ). contains ( moveTwo ); }","title":"Tip 3. Substitute Algorithm"},{"location":"step13/#tip-4-use-polymorphism","text":"State Pattern Strategy Pattern Tambi\u00e9n se puede utilizar patrones de dise\u00f1o como el State Pattern y Strategy Pattern y hacer uso de la herencia. Para ello, crear\u00edamos una clase Base abstracta que tuviera el m\u00e9todo que comprueba si un movimiento gana a otro. Luego crear\u00edamos tantas especificaciones de esa clase como diferentes movimientos existen en el juego. Si aparecen nuevas reglas o movimientos solo hay que crear o modificar las especificaciones.","title":"Tip 4. Use Polymorphism"},{"location":"step13/#con-subclases","text":"Original 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && ( moveTwo . equals ( PlayMove . PAPER ) || moveTwo . equals ( PlayMove . LIZARD ))) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && ( moveTwo . equals ( PlayMove . ROCK ) || moveTwo . equals ( PlayMove . SPOCK ))) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && ( moveTwo . equals ( PlayMove . LIZARD ) || moveTwo . equals ( PlayMove . SCISSORS ))) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && ( moveTwo . equals ( PlayMove . SPOCK ) || moveTwo . equals ( PlayMove . PAPER ))) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && ( moveTwo . equals ( PlayMove . SCISSORS ) || moveTwo . equals ( PlayMove . ROCK ))) return true ; return false ; } Refactorizado 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 public abstract class PlayMove { public static PlayMove ROCK = new MoveRock (); public static PlayMove PAPER = new MovePaper (); public static PlayMove SCISSORS = new MoveScissors (); public static PlayMove LIZARD = new MoveLizard (); public static PlayMove SPOCK = new MoveSpock (); abstract boolean isPlayWinner ( PlayMove move ); } public class MoveRock extends PlayMove { @Override boolean isPlayWinner ( PlayMove move ) { return move . equals ( PlayMove . LIZARD ) || move . equals ( PlayMove . SCISSORS ); } } public class MovePaper extends PlayMove { @Override boolean isPlayWinner ( PlayMove move ) { return move . equals ( PlayMove . ROCK ) || move . equals ( PlayMove . SPOCK ); } } public class MoveScissors extends PlayMove { @Override boolean isPlayWinner ( PlayMove move ) { return move . equals ( PlayMove . PAPER ) || move . equals ( PlayMove . LIZARD ); } } public class MoveLizard extends PlayMove { @Override boolean isPlayWinner ( PlayMove move ) { return move . equals ( PlayMove . SPOCK ) || move . equals ( PlayMove . PAPER ); } } public class MoveSpock extends PlayMove { @Override boolean isPlayWinner ( PlayMove move ) { return move . equals ( PlayMove . SCISSORS ) || move . equals ( PlayMove . ROCK ); } } public class RuleEngine { ... private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { return moveOne . isPlayWinner ( moveTwo ); } ... }","title":"Con subclases"},{"location":"step13/#con-enums","text":"Incluso esto tambi\u00e9n podr\u00eda implementarse con los enum ya que permiten implementar c\u00f3digo dentro del enum . public enum PlayMove { ROCK { @Override boolean isPlayWinner ( PlayMove move ) { return move . equals ( PlayMove . LIZARD ) || move . equals ( PlayMove . SCISSORS ); } }, PAPER { @Override boolean isPlayWinner ( PlayMove move ) { return move . equals ( PlayMove . ROCK ) || move . equals ( PlayMove . SPOCK ); } }, SCISSORS { @Override boolean isPlayWinner ( PlayMove move ) { return move . equals ( PlayMove . PAPER ) || move . equals ( PlayMove . LIZARD ); } }, LIZARD { @Override boolean isPlayWinner ( PlayMove move ) { return move . equals ( PlayMove . SPOCK ) || move . equals ( PlayMove . PAPER ); } }, SPOCK { @Override boolean isPlayWinner ( PlayMove move ) { return move . equals ( PlayMove . SCISSORS ) || move . equals ( PlayMove . ROCK ); } }; abstract boolean isPlayWinner ( PlayMove move ); } public class RuleEngine { ... private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { return moveOne . isPlayWinner ( moveTwo ); } ... }","title":"Con Enums"},{"location":"step2/","text":"Desarrollo del requisito 2 Requisito Las tijeras cortan el papel Desarrollo Se trata de un requisito simple, pero debemos tener en cuenta todas las casu\u00edsticas del test. Es decir debemos probar que las tijeras vencen al papel y que el papel es vencido por las tijeras, de esta forma tenemos todas las combinaciones. TestRuleEngine 1 2 3 4 5 6 7 8 9 @Test public void scissors_cuts_paper () { RuleEngine ruleEngine = new RuleEngine (); Assert . assertEquals ( PlayResult . WIN_PLAYER_ONE , ruleEngine . play ( PlayMove . SCISSORS , PlayMove . PAPER )); Assert . assertEquals ( PlayResult . WIN_PLAYER_TWO , ruleEngine . play ( PlayMove . PAPER , PlayMove . SCISSORS )); } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { PlayResult result = null ; if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) { result = PlayResult . WIN_PLAYER_ONE ; } else if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) { result = PlayResult . WIN_PLAYER_TWO ; } else { result = PlayResult . DRAW ; } return result ; } Algo nos preocupa en este c\u00f3digo, no lo vemos del todo claro y el cuerpo nos pide hacer un poco de Refactor . RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { PlayResult result = null ; if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) { result = PlayResult . WIN_PLAYER_ONE ; } else if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) { /*(1)*/ result = PlayResult . WIN_PLAYER_TWO ; } else { /*(1)*/ result = PlayResult . DRAW ; } return result ; } RuleEngine-Ref1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { PlayResult result = null ; if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) { /*(2)*/ result = PlayResult . WIN_PLAYER_ONE ; } else if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) { /*(2)*/ result = PlayResult . WIN_PLAYER_TWO ; } else { /*(2)*/ result = PlayResult . DRAW ; } return result ; } RuleEngine-Ref2 1 2 3 4 5 6 7 8 9 10 11 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } Refactoring (1) A veces para aumentar la legibilidad del c\u00f3digo nos basta con hacer algo tan tonto como darle aire al c\u00f3digo, dejarle que respire . Unos cuantos saltos de l\u00ednea y hacemos varios bloques m\u00e1s legibles y menos apelotonados. Al cerebro le gusta m\u00e1s leer varios p\u00e1rrafos cortos en vez de un \u00fanico p\u00e1rrafo muy largo. (2) Algo nos dice que esas clausulas if-else no son muy correctas. Todas son excluyentes y en cada una se asigna un valor diferente que luego ser\u00e1 devuelto. Es el t\u00edpico caso de uso de una Clausula de Guarda . Podemos devolver con un return el resultado sin tener que llegar al final del m\u00e9todo. Aumenta la legibilidad porque ayudamos al cerebro a no ir concatenando condiciones y negaciones. Ej: L\u00ednea 5, si se cumple la condici\u00f3n, hago X L\u00ednea 7, si no se cumple la condici\u00f3n 5 y se cumple la condici\u00f3n, hago Y L\u00ednea 9, si no se cumple la condici\u00f3n 5 y tampoco se cumple la condici\u00f3n 7, hago Z Mucho mejor si metemos clausulas de guarda que vayan liberando al cerebro de la pesada carga de tener que recordar condiciones. Algo nos dice que no va a ser f\u00e1cil quitarnos esos if y que, adem\u00e1s, van a ir apareciendo muchos m\u00e1s seg\u00fan avancemos en la implementaci\u00f3n. De momento lo dejaremos pasar. Tampoco debemos olvidar que los Test son parte del c\u00f3digo y se merecen tener un Refactoring , si nos fijamos en la clase de jUnit vemos que tenemos bastante c\u00f3digo duplicado. TestRuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Test public void equals_move_result_draw () { RuleEngine ruleEngine = new RuleEngine (); /*(1)*/ Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . ROCK , PlayMove . ROCK )); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . PAPER , PlayMove . PAPER )); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . SCISSORS , PlayMove . SCISSORS )); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . LIZARD , PlayMove . LIZARD )); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . SPOCK , PlayMove . SPOCK )); } @Test public void scissors_cuts_paper () { RuleEngine ruleEngine = new RuleEngine (); /*(1)*/ Assert . assertEquals ( PlayResult . WIN_PLAYER_ONE , ruleEngine . play ( PlayMove . SCISSORS , PlayMove . PAPER )); Assert . assertEquals ( PlayResult . WIN_PLAYER_TWO , ruleEngine . play ( PlayMove . PAPER , PlayMove . SCISSORS )); } TestRuleEngine-Ref1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 RuleEngine ruleEngine = new RuleEngine (); @Test public void equals_move_result_draw () { Assert . assertEquals ( PlayResult . DRAW , this . ruleEngine . play ( PlayMove . ROCK , PlayMove . ROCK )); /*(2)*/ Assert . assertEquals ( PlayResult . DRAW , this . ruleEngine . play ( PlayMove . PAPER , PlayMove . PAPER )); /*(2)*/ Assert . assertEquals ( PlayResult . DRAW , this . ruleEngine . play ( PlayMove . SCISSORS , PlayMove . SCISSORS )); /*(2)*/ Assert . assertEquals ( PlayResult . DRAW , this . ruleEngine . play ( PlayMove . LIZARD , PlayMove . LIZARD )); /*(2)*/ Assert . assertEquals ( PlayResult . DRAW , this . ruleEngine . play ( PlayMove . SPOCK , PlayMove . SPOCK )); /*(2)*/ } @Test public void scissors_cuts_paper () { Assert . assertEquals ( PlayResult . WIN_PLAYER_ONE , this . ruleEngine . play ( PlayMove . SCISSORS , PlayMove . PAPER )); /*(2)*/ Assert . assertEquals ( PlayResult . WIN_PLAYER_TWO , this . ruleEngine . play ( PlayMove . PAPER , PlayMove . SCISSORS )); /*(2)*/ } TestRuleEngine-Ref2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 RuleEngine ruleEngine = new RuleEngine (); @Test public void equals_move_result_draw () { invokeAndCheckResult ( PlayMove . ROCK , PlayMove . ROCK , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . PAPER , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . SCISSORS , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . LIZARD , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . SPOCK , PlayResult . DRAW ); } @Test public void scissors_cuts_paper () { invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . PAPER , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_TWO ); } private void invokeAndCheckResult ( PlayMove playerOne , PlayMove playerTwo , PlayResult expectedResult ) { Assert . assertEquals ( expectedResult , this . ruleEngine . play ( playerOne , playerTwo )); } Refactoring (1) Ambas l\u00edneas son exactamente iguales, podemos extraer la variable a una global para toda la clase o utilizar alg\u00fan tipo de patr\u00f3n Builder . (2) Pr\u00e1cticamente se hace lo mismo en todo el bloque de l\u00edneas, salvo que se le pasan dos entradas diferentes y se obtiene una salida diferente. Quiz\u00e1 podr\u00edamos encapsularlo todo eso en un m\u00e9todo que fuera m\u00e1s legible. Resultado final Al finalizar obtenemos el siguiente c\u00f3digo: TestRuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class TestRuleEngine { RuleEngine ruleEngine = new RuleEngine (); @Test public void equals_move_result_draw () { invokeAndCheckResult ( PlayMove . ROCK , PlayMove . ROCK , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . PAPER , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . SCISSORS , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . LIZARD , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . SPOCK , PlayResult . DRAW ); } @Test public void scissors_cuts_paper () { invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . PAPER , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_TWO ); } private void invokeAndCheckResult ( PlayMove playerOne , PlayMove playerTwo , PlayResult expectedResult ) { Assert . assertEquals ( expectedResult , this . ruleEngine . play ( playerOne , playerTwo )); } } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class RuleEngine { public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } }","title":"R2. Tijeras cortan Papel"},{"location":"step2/#desarrollo-del-requisito-2","text":"","title":"Desarrollo del requisito 2"},{"location":"step2/#requisito","text":"Las tijeras cortan el papel","title":"Requisito"},{"location":"step2/#desarrollo","text":"Se trata de un requisito simple, pero debemos tener en cuenta todas las casu\u00edsticas del test. Es decir debemos probar que las tijeras vencen al papel y que el papel es vencido por las tijeras, de esta forma tenemos todas las combinaciones. TestRuleEngine 1 2 3 4 5 6 7 8 9 @Test public void scissors_cuts_paper () { RuleEngine ruleEngine = new RuleEngine (); Assert . assertEquals ( PlayResult . WIN_PLAYER_ONE , ruleEngine . play ( PlayMove . SCISSORS , PlayMove . PAPER )); Assert . assertEquals ( PlayResult . WIN_PLAYER_TWO , ruleEngine . play ( PlayMove . PAPER , PlayMove . SCISSORS )); } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { PlayResult result = null ; if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) { result = PlayResult . WIN_PLAYER_ONE ; } else if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) { result = PlayResult . WIN_PLAYER_TWO ; } else { result = PlayResult . DRAW ; } return result ; } Algo nos preocupa en este c\u00f3digo, no lo vemos del todo claro y el cuerpo nos pide hacer un poco de Refactor . RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { PlayResult result = null ; if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) { result = PlayResult . WIN_PLAYER_ONE ; } else if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) { /*(1)*/ result = PlayResult . WIN_PLAYER_TWO ; } else { /*(1)*/ result = PlayResult . DRAW ; } return result ; } RuleEngine-Ref1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { PlayResult result = null ; if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) { /*(2)*/ result = PlayResult . WIN_PLAYER_ONE ; } else if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) { /*(2)*/ result = PlayResult . WIN_PLAYER_TWO ; } else { /*(2)*/ result = PlayResult . DRAW ; } return result ; } RuleEngine-Ref2 1 2 3 4 5 6 7 8 9 10 11 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } Refactoring (1) A veces para aumentar la legibilidad del c\u00f3digo nos basta con hacer algo tan tonto como darle aire al c\u00f3digo, dejarle que respire . Unos cuantos saltos de l\u00ednea y hacemos varios bloques m\u00e1s legibles y menos apelotonados. Al cerebro le gusta m\u00e1s leer varios p\u00e1rrafos cortos en vez de un \u00fanico p\u00e1rrafo muy largo. (2) Algo nos dice que esas clausulas if-else no son muy correctas. Todas son excluyentes y en cada una se asigna un valor diferente que luego ser\u00e1 devuelto. Es el t\u00edpico caso de uso de una Clausula de Guarda . Podemos devolver con un return el resultado sin tener que llegar al final del m\u00e9todo. Aumenta la legibilidad porque ayudamos al cerebro a no ir concatenando condiciones y negaciones. Ej: L\u00ednea 5, si se cumple la condici\u00f3n, hago X L\u00ednea 7, si no se cumple la condici\u00f3n 5 y se cumple la condici\u00f3n, hago Y L\u00ednea 9, si no se cumple la condici\u00f3n 5 y tampoco se cumple la condici\u00f3n 7, hago Z Mucho mejor si metemos clausulas de guarda que vayan liberando al cerebro de la pesada carga de tener que recordar condiciones. Algo nos dice que no va a ser f\u00e1cil quitarnos esos if y que, adem\u00e1s, van a ir apareciendo muchos m\u00e1s seg\u00fan avancemos en la implementaci\u00f3n. De momento lo dejaremos pasar. Tampoco debemos olvidar que los Test son parte del c\u00f3digo y se merecen tener un Refactoring , si nos fijamos en la clase de jUnit vemos que tenemos bastante c\u00f3digo duplicado. TestRuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Test public void equals_move_result_draw () { RuleEngine ruleEngine = new RuleEngine (); /*(1)*/ Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . ROCK , PlayMove . ROCK )); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . PAPER , PlayMove . PAPER )); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . SCISSORS , PlayMove . SCISSORS )); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . LIZARD , PlayMove . LIZARD )); Assert . assertEquals ( PlayResult . DRAW , ruleEngine . play ( PlayMove . SPOCK , PlayMove . SPOCK )); } @Test public void scissors_cuts_paper () { RuleEngine ruleEngine = new RuleEngine (); /*(1)*/ Assert . assertEquals ( PlayResult . WIN_PLAYER_ONE , ruleEngine . play ( PlayMove . SCISSORS , PlayMove . PAPER )); Assert . assertEquals ( PlayResult . WIN_PLAYER_TWO , ruleEngine . play ( PlayMove . PAPER , PlayMove . SCISSORS )); } TestRuleEngine-Ref1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 RuleEngine ruleEngine = new RuleEngine (); @Test public void equals_move_result_draw () { Assert . assertEquals ( PlayResult . DRAW , this . ruleEngine . play ( PlayMove . ROCK , PlayMove . ROCK )); /*(2)*/ Assert . assertEquals ( PlayResult . DRAW , this . ruleEngine . play ( PlayMove . PAPER , PlayMove . PAPER )); /*(2)*/ Assert . assertEquals ( PlayResult . DRAW , this . ruleEngine . play ( PlayMove . SCISSORS , PlayMove . SCISSORS )); /*(2)*/ Assert . assertEquals ( PlayResult . DRAW , this . ruleEngine . play ( PlayMove . LIZARD , PlayMove . LIZARD )); /*(2)*/ Assert . assertEquals ( PlayResult . DRAW , this . ruleEngine . play ( PlayMove . SPOCK , PlayMove . SPOCK )); /*(2)*/ } @Test public void scissors_cuts_paper () { Assert . assertEquals ( PlayResult . WIN_PLAYER_ONE , this . ruleEngine . play ( PlayMove . SCISSORS , PlayMove . PAPER )); /*(2)*/ Assert . assertEquals ( PlayResult . WIN_PLAYER_TWO , this . ruleEngine . play ( PlayMove . PAPER , PlayMove . SCISSORS )); /*(2)*/ } TestRuleEngine-Ref2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 RuleEngine ruleEngine = new RuleEngine (); @Test public void equals_move_result_draw () { invokeAndCheckResult ( PlayMove . ROCK , PlayMove . ROCK , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . PAPER , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . SCISSORS , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . LIZARD , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . SPOCK , PlayResult . DRAW ); } @Test public void scissors_cuts_paper () { invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . PAPER , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_TWO ); } private void invokeAndCheckResult ( PlayMove playerOne , PlayMove playerTwo , PlayResult expectedResult ) { Assert . assertEquals ( expectedResult , this . ruleEngine . play ( playerOne , playerTwo )); } Refactoring (1) Ambas l\u00edneas son exactamente iguales, podemos extraer la variable a una global para toda la clase o utilizar alg\u00fan tipo de patr\u00f3n Builder . (2) Pr\u00e1cticamente se hace lo mismo en todo el bloque de l\u00edneas, salvo que se le pasan dos entradas diferentes y se obtiene una salida diferente. Quiz\u00e1 podr\u00edamos encapsularlo todo eso en un m\u00e9todo que fuera m\u00e1s legible.","title":"Desarrollo"},{"location":"step2/#resultado-final","text":"Al finalizar obtenemos el siguiente c\u00f3digo: TestRuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class TestRuleEngine { RuleEngine ruleEngine = new RuleEngine (); @Test public void equals_move_result_draw () { invokeAndCheckResult ( PlayMove . ROCK , PlayMove . ROCK , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . PAPER , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . SCISSORS , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . LIZARD , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . SPOCK , PlayResult . DRAW ); } @Test public void scissors_cuts_paper () { invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . PAPER , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_TWO ); } private void invokeAndCheckResult ( PlayMove playerOne , PlayMove playerTwo , PlayResult expectedResult ) { Assert . assertEquals ( expectedResult , this . ruleEngine . play ( playerOne , playerTwo )); } } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class RuleEngine { public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } }","title":"Resultado final"},{"location":"step3/","text":"Desarrollo del requisito 3 Requisito El papel recubre la piedra Desarrollo Este requisito, igual que el anterior, es bastante sencillo. TestRuleEngine 1 2 3 4 5 6 7 @Test public void paper_cover_rock () { invokeAndCheckResult ( PlayMove . PAPER , PlayMove . ROCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . ROCK , PlayMove . PAPER , PlayResult . WIN_PLAYER_TWO ); } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . ROCK )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } Vemos con impotencia como van creciendo los if y no sabemos como resolverlos. A simple vista no podemos Refactorizar mucho m\u00e1s. De momento lo dejamos pasar y al final veremos como podemos solucionarlo.","title":"R3. Papel recubre Piedra"},{"location":"step3/#desarrollo-del-requisito-3","text":"","title":"Desarrollo del requisito 3"},{"location":"step3/#requisito","text":"El papel recubre la piedra","title":"Requisito"},{"location":"step3/#desarrollo","text":"Este requisito, igual que el anterior, es bastante sencillo. TestRuleEngine 1 2 3 4 5 6 7 @Test public void paper_cover_rock () { invokeAndCheckResult ( PlayMove . PAPER , PlayMove . ROCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . ROCK , PlayMove . PAPER , PlayResult . WIN_PLAYER_TWO ); } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . ROCK )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } Vemos con impotencia como van creciendo los if y no sabemos como resolverlos. A simple vista no podemos Refactorizar mucho m\u00e1s. De momento lo dejamos pasar y al final veremos como podemos solucionarlo.","title":"Desarrollo"},{"location":"step4/","text":"Desarrollo del requisito 4 Requisito La piedra aplasta al lagargo Desarrollo Este requisito, igual que el anterior, es bastante sencillo. TestRuleEngine 1 2 3 4 5 6 7 @Test public void rock_crushes_lizard () { invokeAndCheckResult ( PlayMove . ROCK , PlayMove . LIZARD , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . ROCK , PlayResult . WIN_PLAYER_TWO ); } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . ROCK )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . LIZARD )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . LIZARD ) && playerTwo . equals ( PlayMove . ROCK )) return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } Y sigue creciendo el m\u00e9todo, y nos vamos incomodando cada vez m\u00e1s.","title":"R4. Piedra aplasta Lagarto"},{"location":"step4/#desarrollo-del-requisito-4","text":"","title":"Desarrollo del requisito 4"},{"location":"step4/#requisito","text":"La piedra aplasta al lagargo","title":"Requisito"},{"location":"step4/#desarrollo","text":"Este requisito, igual que el anterior, es bastante sencillo. TestRuleEngine 1 2 3 4 5 6 7 @Test public void rock_crushes_lizard () { invokeAndCheckResult ( PlayMove . ROCK , PlayMove . LIZARD , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . ROCK , PlayResult . WIN_PLAYER_TWO ); } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . ROCK )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . LIZARD )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . LIZARD ) && playerTwo . equals ( PlayMove . ROCK )) return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } Y sigue creciendo el m\u00e9todo, y nos vamos incomodando cada vez m\u00e1s.","title":"Desarrollo"},{"location":"step5/","text":"Desarrollo del requisito 5 Requisito El lagarto envenena a Spock Desarrollo De nuevo, un requisito muy sencillo. TestRuleEngine 1 2 3 4 5 6 7 @Test public void lizard_poisons_spock () { invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . SPOCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . LIZARD , PlayResult . WIN_PLAYER_TWO ); } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . ROCK )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . LIZARD )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . LIZARD ) && playerTwo . equals ( PlayMove . ROCK )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . LIZARD ) && playerTwo . equals ( PlayMove . SPOCK )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . SPOCK ) && playerTwo . equals ( PlayMove . LIZARD )) return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } El m\u00e9todo no parece tener fin, podemos empezar a llorar no sabemos como parar esto.","title":"R5. Lagarto envenena Spock"},{"location":"step5/#desarrollo-del-requisito-5","text":"","title":"Desarrollo del requisito 5"},{"location":"step5/#requisito","text":"El lagarto envenena a Spock","title":"Requisito"},{"location":"step5/#desarrollo","text":"De nuevo, un requisito muy sencillo. TestRuleEngine 1 2 3 4 5 6 7 @Test public void lizard_poisons_spock () { invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . SPOCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . LIZARD , PlayResult . WIN_PLAYER_TWO ); } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . ROCK )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . LIZARD )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . LIZARD ) && playerTwo . equals ( PlayMove . ROCK )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . LIZARD ) && playerTwo . equals ( PlayMove . SPOCK )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . SPOCK ) && playerTwo . equals ( PlayMove . LIZARD )) return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } El m\u00e9todo no parece tener fin, podemos empezar a llorar no sabemos como parar esto.","title":"Desarrollo"},{"location":"step6/","text":"Desarrollo del requisito 6 Requisito Spock rompe las tijeras Desarrollo De nuevo, un requisito muy sencillo. TestRuleEngine 1 2 3 4 5 6 7 @Test public void spock_smashes_scissors () { invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . SPOCK , PlayResult . WIN_PLAYER_TWO ); } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . ROCK )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . LIZARD )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . LIZARD ) && playerTwo . equals ( PlayMove . ROCK )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . LIZARD ) && playerTwo . equals ( PlayMove . SPOCK )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . SPOCK ) && playerTwo . equals ( PlayMove . LIZARD )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . SPOCK ) && playerTwo . equals ( PlayMove . SCISSORS )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . SPOCK )) return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } Bueno, ya est\u00e1 bien, vamos a ver si podemos hacer algo con el m\u00e9todo. Es demasiado grande y con demasiados if . Vamos a intentar hacer algo aunque no sepamos todav\u00eda como eliminar esos if , por lo menos darle algo de legibilidad. RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_ONE ; /*(1)*/ if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . ROCK )) return PlayResult . WIN_PLAYER_ONE ; /*(1)*/ if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . LIZARD )) return PlayResult . WIN_PLAYER_ONE ; /*(1)*/ if ( playerOne . equals ( PlayMove . LIZARD ) && playerTwo . equals ( PlayMove . ROCK )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . LIZARD ) && playerTwo . equals ( PlayMove . SPOCK )) return PlayResult . WIN_PLAYER_ONE ; /*(1)*/ if ( playerOne . equals ( PlayMove . SPOCK ) && playerTwo . equals ( PlayMove . LIZARD )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . SPOCK ) && playerTwo . equals ( PlayMove . SCISSORS )) return PlayResult . WIN_PLAYER_ONE ; /*(1)*/ if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . SPOCK )) return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } RuleEngine-Ref1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) /*(2)*/ return PlayResult . WIN_PLAYER_ONE ; /*(2)*/ if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . ROCK )) /*(2)*/ return PlayResult . WIN_PLAYER_ONE ; /*(2)*/ if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . LIZARD )) /*(2)*/ return PlayResult . WIN_PLAYER_ONE ; /*(2)*/ if ( playerOne . equals ( PlayMove . LIZARD ) && playerTwo . equals ( PlayMove . SPOCK )) /*(2)*/ return PlayResult . WIN_PLAYER_ONE ; /*(2)*/ if ( playerOne . equals ( PlayMove . SPOCK ) && playerTwo . equals ( PlayMove . SCISSORS )) /*(2)*/ return PlayResult . WIN_PLAYER_ONE ; /*(2)*/ if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) /*(3)*/ return PlayResult . WIN_PLAYER_TWO ; /*(3)*/ if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . PAPER )) /*(3)*/ return PlayResult . WIN_PLAYER_TWO ; /*(3)*/ if ( playerOne . equals ( PlayMove . LIZARD ) && playerTwo . equals ( PlayMove . ROCK )) /*(3)*/ return PlayResult . WIN_PLAYER_TWO ; /*(3)*/ if ( playerOne . equals ( PlayMove . SPOCK ) && playerTwo . equals ( PlayMove . LIZARD )) /*(3)*/ return PlayResult . WIN_PLAYER_TWO ; /*(3)*/ if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . SPOCK )) /*(3)*/ return PlayResult . WIN_PLAYER_TWO ; /*(3)*/ return PlayResult . DRAW ; } RuleEngine-Ref2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( isPlayerOneWinner ( playerOne , playerTwo )) /*(4)*/ return PlayResult . WIN_PLAYER_ONE ; if ( isPlayerTwoWinner ( playerOne , playerTwo )) /*(4)*/ return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } private boolean isPlayerOneWinner ( PlayMove playerOne , PlayMove playerTwo ) { /*(4)*/ if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) /*(4)*/ return true ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . ROCK )) /*(4)*/ return true ; if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . LIZARD )) /*(4)*/ return true ; if ( playerOne . equals ( PlayMove . LIZARD ) && playerTwo . equals ( PlayMove . SPOCK )) /*(4)*/ return true ; if ( playerOne . equals ( PlayMove . SPOCK ) && playerTwo . equals ( PlayMove . SCISSORS )) /*(4)*/ return true ; return false ; } private boolean isPlayerTwoWinner ( PlayMove playerOne , PlayMove playerTwo ) { if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) /*(4)*/ return true ; if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . PAPER )) /*(4)*/ return true ; if ( playerOne . equals ( PlayMove . LIZARD ) && playerTwo . equals ( PlayMove . ROCK )) /*(4)*/ return true ; if ( playerOne . equals ( PlayMove . SPOCK ) && playerTwo . equals ( PlayMove . LIZARD )) /*(4)*/ return true ; if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . SPOCK )) /*(4)*/ return true ; return false ; } RuleEngine-Ref3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( isPlayerOneWinner ( playerOne , playerTwo )) return PlayResult . WIN_PLAYER_ONE ; if ( isPlayerTwoWinner ( playerOne , playerTwo )) return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } private boolean isPlayerOneWinner ( PlayMove playerOne , PlayMove playerTwo ) { return isPlayWinner ( playerOne , playerTwo ); } private boolean isPlayerTwoWinner ( PlayMove playerOne , PlayMove playerTwo ) { return isPlayWinner ( playerTwo , playerOne ); } private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && moveTwo . equals ( PlayMove . PAPER )) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && moveTwo . equals ( PlayMove . ROCK )) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && moveTwo . equals ( PlayMove . LIZARD )) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && moveTwo . equals ( PlayMove . SPOCK )) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && moveTwo . equals ( PlayMove . SCISSORS )) return true ; return false ; } Refactoring (1) Vamos a agrupar todas las clausulas donde el jugar uno gana, y todas donde el jugador dos gana. (2) Pr\u00e1cticamente se hace lo mismo en todo el bloque de l\u00edneas, salvo que se le pasan dos entradas diferentes y se obtiene una salida diferente. Quiz\u00e1 podr\u00edamos encapsularlo todo eso en un m\u00e9todo que fuera m\u00e1s legible. (3) Lo mismo que para el punto anterior, podemos extraer un m\u00e9todo. (4) Fij\u00e1ndonos mucho, podemos intuir que los dos m\u00e9todos hacen lo mismo, es c\u00f3digo duplicado, solo que el primer m\u00e9todo lo hace en un sentido, y el segundo m\u00e9todo lo hace en el sentido inverso. Podemos crearnos un m\u00e9todo Ahora ya tenemos un c\u00f3digo un poco m\u00e1s arreglado, aunque seguimos teniendo algunos if que vamos a dejar de momento, vamos a ver como progresa la implementaci\u00f3n. Resultado final Despu\u00e9s de todos estos tests y refactor deber\u00edamos tener el siguiente c\u00f3digo: TestRuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 public class TestRuleEngine { RuleEngine ruleEngine = new RuleEngine (); @Test public void equals_move_result_draw () { invokeAndCheckResult ( PlayMove . ROCK , PlayMove . ROCK , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . PAPER , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . SCISSORS , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . LIZARD , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . SPOCK , PlayResult . DRAW ); } @Test public void scissors_cuts_paper () { invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . PAPER , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_TWO ); } @Test public void paper_cover_rock () { invokeAndCheckResult ( PlayMove . PAPER , PlayMove . ROCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . ROCK , PlayMove . PAPER , PlayResult . WIN_PLAYER_TWO ); } @Test public void rock_crushes_lizard () { invokeAndCheckResult ( PlayMove . ROCK , PlayMove . LIZARD , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . ROCK , PlayResult . WIN_PLAYER_TWO ); } @Test public void lizard_poisons_spock () { invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . SPOCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . LIZARD , PlayResult . WIN_PLAYER_TWO ); } @Test public void spock_smashes_scissors () { invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . SPOCK , PlayResult . WIN_PLAYER_TWO ); } private void invokeAndCheckResult ( PlayMove playerOne , PlayMove playerTwo , PlayResult expectedResult ) { Assert . assertEquals ( expectedResult , this . ruleEngine . play ( playerOne , playerTwo )); } } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public class RuleEngine { public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( isPlayerOneWinner ( playerOne , playerTwo )) return PlayResult . WIN_PLAYER_ONE ; if ( isPlayerTwoWinner ( playerOne , playerTwo )) return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } private boolean isPlayerOneWinner ( PlayMove playerOne , PlayMove playerTwo ) { return isPlayWinner ( playerOne , playerTwo ); } private boolean isPlayerTwoWinner ( PlayMove playerOne , PlayMove playerTwo ) { return isPlayWinner ( playerTwo , playerOne ); } private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && moveTwo . equals ( PlayMove . PAPER )) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && moveTwo . equals ( PlayMove . ROCK )) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && moveTwo . equals ( PlayMove . LIZARD )) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && moveTwo . equals ( PlayMove . SPOCK )) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && moveTwo . equals ( PlayMove . SCISSORS )) return true ; return false ; } }","title":"R6. Spock rompe Tijeras"},{"location":"step6/#desarrollo-del-requisito-6","text":"","title":"Desarrollo del requisito 6"},{"location":"step6/#requisito","text":"Spock rompe las tijeras","title":"Requisito"},{"location":"step6/#desarrollo","text":"De nuevo, un requisito muy sencillo. TestRuleEngine 1 2 3 4 5 6 7 @Test public void spock_smashes_scissors () { invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . SPOCK , PlayResult . WIN_PLAYER_TWO ); } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . ROCK )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . LIZARD )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . LIZARD ) && playerTwo . equals ( PlayMove . ROCK )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . LIZARD ) && playerTwo . equals ( PlayMove . SPOCK )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . SPOCK ) && playerTwo . equals ( PlayMove . LIZARD )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . SPOCK ) && playerTwo . equals ( PlayMove . SCISSORS )) return PlayResult . WIN_PLAYER_ONE ; if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . SPOCK )) return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } Bueno, ya est\u00e1 bien, vamos a ver si podemos hacer algo con el m\u00e9todo. Es demasiado grande y con demasiados if . Vamos a intentar hacer algo aunque no sepamos todav\u00eda como eliminar esos if , por lo menos darle algo de legibilidad. RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_ONE ; /*(1)*/ if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . ROCK )) return PlayResult . WIN_PLAYER_ONE ; /*(1)*/ if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . PAPER )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . LIZARD )) return PlayResult . WIN_PLAYER_ONE ; /*(1)*/ if ( playerOne . equals ( PlayMove . LIZARD ) && playerTwo . equals ( PlayMove . ROCK )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . LIZARD ) && playerTwo . equals ( PlayMove . SPOCK )) return PlayResult . WIN_PLAYER_ONE ; /*(1)*/ if ( playerOne . equals ( PlayMove . SPOCK ) && playerTwo . equals ( PlayMove . LIZARD )) return PlayResult . WIN_PLAYER_TWO ; if ( playerOne . equals ( PlayMove . SPOCK ) && playerTwo . equals ( PlayMove . SCISSORS )) return PlayResult . WIN_PLAYER_ONE ; /*(1)*/ if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . SPOCK )) return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } RuleEngine-Ref1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) /*(2)*/ return PlayResult . WIN_PLAYER_ONE ; /*(2)*/ if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . ROCK )) /*(2)*/ return PlayResult . WIN_PLAYER_ONE ; /*(2)*/ if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . LIZARD )) /*(2)*/ return PlayResult . WIN_PLAYER_ONE ; /*(2)*/ if ( playerOne . equals ( PlayMove . LIZARD ) && playerTwo . equals ( PlayMove . SPOCK )) /*(2)*/ return PlayResult . WIN_PLAYER_ONE ; /*(2)*/ if ( playerOne . equals ( PlayMove . SPOCK ) && playerTwo . equals ( PlayMove . SCISSORS )) /*(2)*/ return PlayResult . WIN_PLAYER_ONE ; /*(2)*/ if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) /*(3)*/ return PlayResult . WIN_PLAYER_TWO ; /*(3)*/ if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . PAPER )) /*(3)*/ return PlayResult . WIN_PLAYER_TWO ; /*(3)*/ if ( playerOne . equals ( PlayMove . LIZARD ) && playerTwo . equals ( PlayMove . ROCK )) /*(3)*/ return PlayResult . WIN_PLAYER_TWO ; /*(3)*/ if ( playerOne . equals ( PlayMove . SPOCK ) && playerTwo . equals ( PlayMove . LIZARD )) /*(3)*/ return PlayResult . WIN_PLAYER_TWO ; /*(3)*/ if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . SPOCK )) /*(3)*/ return PlayResult . WIN_PLAYER_TWO ; /*(3)*/ return PlayResult . DRAW ; } RuleEngine-Ref2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( isPlayerOneWinner ( playerOne , playerTwo )) /*(4)*/ return PlayResult . WIN_PLAYER_ONE ; if ( isPlayerTwoWinner ( playerOne , playerTwo )) /*(4)*/ return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } private boolean isPlayerOneWinner ( PlayMove playerOne , PlayMove playerTwo ) { /*(4)*/ if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . PAPER )) /*(4)*/ return true ; if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . ROCK )) /*(4)*/ return true ; if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . LIZARD )) /*(4)*/ return true ; if ( playerOne . equals ( PlayMove . LIZARD ) && playerTwo . equals ( PlayMove . SPOCK )) /*(4)*/ return true ; if ( playerOne . equals ( PlayMove . SPOCK ) && playerTwo . equals ( PlayMove . SCISSORS )) /*(4)*/ return true ; return false ; } private boolean isPlayerTwoWinner ( PlayMove playerOne , PlayMove playerTwo ) { if ( playerOne . equals ( PlayMove . PAPER ) && playerTwo . equals ( PlayMove . SCISSORS )) /*(4)*/ return true ; if ( playerOne . equals ( PlayMove . ROCK ) && playerTwo . equals ( PlayMove . PAPER )) /*(4)*/ return true ; if ( playerOne . equals ( PlayMove . LIZARD ) && playerTwo . equals ( PlayMove . ROCK )) /*(4)*/ return true ; if ( playerOne . equals ( PlayMove . SPOCK ) && playerTwo . equals ( PlayMove . LIZARD )) /*(4)*/ return true ; if ( playerOne . equals ( PlayMove . SCISSORS ) && playerTwo . equals ( PlayMove . SPOCK )) /*(4)*/ return true ; return false ; } RuleEngine-Ref3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( isPlayerOneWinner ( playerOne , playerTwo )) return PlayResult . WIN_PLAYER_ONE ; if ( isPlayerTwoWinner ( playerOne , playerTwo )) return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } private boolean isPlayerOneWinner ( PlayMove playerOne , PlayMove playerTwo ) { return isPlayWinner ( playerOne , playerTwo ); } private boolean isPlayerTwoWinner ( PlayMove playerOne , PlayMove playerTwo ) { return isPlayWinner ( playerTwo , playerOne ); } private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && moveTwo . equals ( PlayMove . PAPER )) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && moveTwo . equals ( PlayMove . ROCK )) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && moveTwo . equals ( PlayMove . LIZARD )) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && moveTwo . equals ( PlayMove . SPOCK )) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && moveTwo . equals ( PlayMove . SCISSORS )) return true ; return false ; } Refactoring (1) Vamos a agrupar todas las clausulas donde el jugar uno gana, y todas donde el jugador dos gana. (2) Pr\u00e1cticamente se hace lo mismo en todo el bloque de l\u00edneas, salvo que se le pasan dos entradas diferentes y se obtiene una salida diferente. Quiz\u00e1 podr\u00edamos encapsularlo todo eso en un m\u00e9todo que fuera m\u00e1s legible. (3) Lo mismo que para el punto anterior, podemos extraer un m\u00e9todo. (4) Fij\u00e1ndonos mucho, podemos intuir que los dos m\u00e9todos hacen lo mismo, es c\u00f3digo duplicado, solo que el primer m\u00e9todo lo hace en un sentido, y el segundo m\u00e9todo lo hace en el sentido inverso. Podemos crearnos un m\u00e9todo Ahora ya tenemos un c\u00f3digo un poco m\u00e1s arreglado, aunque seguimos teniendo algunos if que vamos a dejar de momento, vamos a ver como progresa la implementaci\u00f3n.","title":"Desarrollo"},{"location":"step6/#resultado-final","text":"Despu\u00e9s de todos estos tests y refactor deber\u00edamos tener el siguiente c\u00f3digo: TestRuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 public class TestRuleEngine { RuleEngine ruleEngine = new RuleEngine (); @Test public void equals_move_result_draw () { invokeAndCheckResult ( PlayMove . ROCK , PlayMove . ROCK , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . PAPER , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . SCISSORS , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . LIZARD , PlayResult . DRAW ); invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . SPOCK , PlayResult . DRAW ); } @Test public void scissors_cuts_paper () { invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . PAPER , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_TWO ); } @Test public void paper_cover_rock () { invokeAndCheckResult ( PlayMove . PAPER , PlayMove . ROCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . ROCK , PlayMove . PAPER , PlayResult . WIN_PLAYER_TWO ); } @Test public void rock_crushes_lizard () { invokeAndCheckResult ( PlayMove . ROCK , PlayMove . LIZARD , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . ROCK , PlayResult . WIN_PLAYER_TWO ); } @Test public void lizard_poisons_spock () { invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . SPOCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . LIZARD , PlayResult . WIN_PLAYER_TWO ); } @Test public void spock_smashes_scissors () { invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . SPOCK , PlayResult . WIN_PLAYER_TWO ); } private void invokeAndCheckResult ( PlayMove playerOne , PlayMove playerTwo , PlayResult expectedResult ) { Assert . assertEquals ( expectedResult , this . ruleEngine . play ( playerOne , playerTwo )); } } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public class RuleEngine { public PlayResult play ( PlayMove playerOne , PlayMove playerTwo ) { if ( isPlayerOneWinner ( playerOne , playerTwo )) return PlayResult . WIN_PLAYER_ONE ; if ( isPlayerTwoWinner ( playerOne , playerTwo )) return PlayResult . WIN_PLAYER_TWO ; return PlayResult . DRAW ; } private boolean isPlayerOneWinner ( PlayMove playerOne , PlayMove playerTwo ) { return isPlayWinner ( playerOne , playerTwo ); } private boolean isPlayerTwoWinner ( PlayMove playerOne , PlayMove playerTwo ) { return isPlayWinner ( playerTwo , playerOne ); } private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && moveTwo . equals ( PlayMove . PAPER )) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && moveTwo . equals ( PlayMove . ROCK )) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && moveTwo . equals ( PlayMove . LIZARD )) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && moveTwo . equals ( PlayMove . SPOCK )) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && moveTwo . equals ( PlayMove . SCISSORS )) return true ; return false ; } }","title":"Resultado final"},{"location":"step7/","text":"Desarrollo del requisito 7 Requisito Las tijeras decapitan al lagarto Desarrollo Para este nuevo requisito, ya sabemos que debemos a\u00f1adir la condici\u00f3n en un m\u00e9todo concreto. TestRuleEngine 1 2 3 4 5 6 7 @Test public void scissors_decapitates_lizard () { invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . LIZARD , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_TWO ); } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && moveTwo . equals ( PlayMove . PAPER )) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && moveTwo . equals ( PlayMove . ROCK )) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && moveTwo . equals ( PlayMove . LIZARD )) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && moveTwo . equals ( PlayMove . SPOCK )) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && moveTwo . equals ( PlayMove . SCISSORS )) return true ; if ( moveOne . equals ( PlayMove . SCISSORS ) && moveTwo . equals ( PlayMove . LIZARD )) return true ; return false ; } Lo a\u00f1adimos como una regla m\u00e1s y ya funciona el test. Pero dentro de ese c\u00f3digo, tenemos algo de c\u00f3digo duplicado, que podemos refactorizar. RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && moveTwo . equals ( PlayMove . PAPER )) /*(1)*/ return true ; if ( moveOne . equals ( PlayMove . PAPER ) && moveTwo . equals ( PlayMove . ROCK )) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && moveTwo . equals ( PlayMove . LIZARD )) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && moveTwo . equals ( PlayMove . SPOCK )) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && moveTwo . equals ( PlayMove . SCISSORS )) return true ; if ( moveOne . equals ( PlayMove . SCISSORS ) && moveTwo . equals ( PlayMove . LIZARD )) /*(1)*/ return true ; return false ; } RuleEngine-Ref1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && ( moveTwo . equals ( PlayMove . PAPER ) || moveTwo . equals ( PlayMove . LIZARD ))) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && moveTwo . equals ( PlayMove . ROCK )) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && moveTwo . equals ( PlayMove . LIZARD )) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && moveTwo . equals ( PlayMove . SPOCK )) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && moveTwo . equals ( PlayMove . SCISSORS )) return true ; return false ; } Refactoring (1) La condici\u00f3n primera en ambas sentencias if es la misma, as\u00ed que podr\u00edamos agruparlo en una sola l\u00ednea. Algo nos dice que los futuros requisitos van a ir a\u00f1adiendo condiciones dobles a todos los movimientos.","title":"R7. Tijeras decapitan Lagarto"},{"location":"step7/#desarrollo-del-requisito-7","text":"","title":"Desarrollo del requisito 7"},{"location":"step7/#requisito","text":"Las tijeras decapitan al lagarto","title":"Requisito"},{"location":"step7/#desarrollo","text":"Para este nuevo requisito, ya sabemos que debemos a\u00f1adir la condici\u00f3n en un m\u00e9todo concreto. TestRuleEngine 1 2 3 4 5 6 7 @Test public void scissors_decapitates_lizard () { invokeAndCheckResult ( PlayMove . SCISSORS , PlayMove . LIZARD , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . SCISSORS , PlayResult . WIN_PLAYER_TWO ); } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && moveTwo . equals ( PlayMove . PAPER )) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && moveTwo . equals ( PlayMove . ROCK )) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && moveTwo . equals ( PlayMove . LIZARD )) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && moveTwo . equals ( PlayMove . SPOCK )) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && moveTwo . equals ( PlayMove . SCISSORS )) return true ; if ( moveOne . equals ( PlayMove . SCISSORS ) && moveTwo . equals ( PlayMove . LIZARD )) return true ; return false ; } Lo a\u00f1adimos como una regla m\u00e1s y ya funciona el test. Pero dentro de ese c\u00f3digo, tenemos algo de c\u00f3digo duplicado, que podemos refactorizar. RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && moveTwo . equals ( PlayMove . PAPER )) /*(1)*/ return true ; if ( moveOne . equals ( PlayMove . PAPER ) && moveTwo . equals ( PlayMove . ROCK )) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && moveTwo . equals ( PlayMove . LIZARD )) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && moveTwo . equals ( PlayMove . SPOCK )) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && moveTwo . equals ( PlayMove . SCISSORS )) return true ; if ( moveOne . equals ( PlayMove . SCISSORS ) && moveTwo . equals ( PlayMove . LIZARD )) /*(1)*/ return true ; return false ; } RuleEngine-Ref1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && ( moveTwo . equals ( PlayMove . PAPER ) || moveTwo . equals ( PlayMove . LIZARD ))) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && moveTwo . equals ( PlayMove . ROCK )) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && moveTwo . equals ( PlayMove . LIZARD )) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && moveTwo . equals ( PlayMove . SPOCK )) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && moveTwo . equals ( PlayMove . SCISSORS )) return true ; return false ; } Refactoring (1) La condici\u00f3n primera en ambas sentencias if es la misma, as\u00ed que podr\u00edamos agruparlo en una sola l\u00ednea. Algo nos dice que los futuros requisitos van a ir a\u00f1adiendo condiciones dobles a todos los movimientos.","title":"Desarrollo"},{"location":"step8/","text":"Desarrollo del requisito 8 Requisito El lagarto se come el papel Desarrollo Nuevo requisito que podemos agrupar. TestRuleEngine 1 2 3 4 5 6 7 @Test public void lizard_eats_paper () { invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . PAPER , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . LIZARD , PlayResult . WIN_PLAYER_TWO ); } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && ( moveTwo . equals ( PlayMove . PAPER ) || moveTwo . equals ( PlayMove . LIZARD ))) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && moveTwo . equals ( PlayMove . ROCK )) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && moveTwo . equals ( PlayMove . LIZARD )) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && ( moveTwo . equals ( PlayMove . SPOCK ) || moveTwo . equals ( PlayMove . PAPER ))) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && moveTwo . equals ( PlayMove . SCISSORS )) return true ; return false ; } Pues si, era lo que hab\u00edamos imaginado, vamos a\u00f1adiendo reglas a los movimientos ya establecidos.","title":"R8. Lagarto come Papel"},{"location":"step8/#desarrollo-del-requisito-8","text":"","title":"Desarrollo del requisito 8"},{"location":"step8/#requisito","text":"El lagarto se come el papel","title":"Requisito"},{"location":"step8/#desarrollo","text":"Nuevo requisito que podemos agrupar. TestRuleEngine 1 2 3 4 5 6 7 @Test public void lizard_eats_paper () { invokeAndCheckResult ( PlayMove . LIZARD , PlayMove . PAPER , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . PAPER , PlayMove . LIZARD , PlayResult . WIN_PLAYER_TWO ); } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && ( moveTwo . equals ( PlayMove . PAPER ) || moveTwo . equals ( PlayMove . LIZARD ))) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && moveTwo . equals ( PlayMove . ROCK )) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && moveTwo . equals ( PlayMove . LIZARD )) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && ( moveTwo . equals ( PlayMove . SPOCK ) || moveTwo . equals ( PlayMove . PAPER ))) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && moveTwo . equals ( PlayMove . SCISSORS )) return true ; return false ; } Pues si, era lo que hab\u00edamos imaginado, vamos a\u00f1adiendo reglas a los movimientos ya establecidos.","title":"Desarrollo"},{"location":"step9/","text":"Desarrollo del requisito 9 Requisito El papel desaprueba a Spock Desarrollo Nuevo requisito que podemos agrupar. TestRuleEngine 1 2 3 4 5 6 7 @Test public void paper_disproves_spock () { invokeAndCheckResult ( PlayMove . PAPER , PlayMove . SPOCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . PAPER , PlayResult . WIN_PLAYER_TWO ); } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && ( moveTwo . equals ( PlayMove . PAPER ) || moveTwo . equals ( PlayMove . LIZARD ))) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && ( moveTwo . equals ( PlayMove . ROCK ) || moveTwo . equals ( PlayMove . SPOCK ))) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && moveTwo . equals ( PlayMove . LIZARD )) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && ( moveTwo . equals ( PlayMove . SPOCK ) || moveTwo . equals ( PlayMove . PAPER ))) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && moveTwo . equals ( PlayMove . SCISSORS )) return true ; return false ; } Otro requisito m\u00e1s, ya faltan menos.","title":"R9. Papel desaprueba Spock"},{"location":"step9/#desarrollo-del-requisito-9","text":"","title":"Desarrollo del requisito 9"},{"location":"step9/#requisito","text":"El papel desaprueba a Spock","title":"Requisito"},{"location":"step9/#desarrollo","text":"Nuevo requisito que podemos agrupar. TestRuleEngine 1 2 3 4 5 6 7 @Test public void paper_disproves_spock () { invokeAndCheckResult ( PlayMove . PAPER , PlayMove . SPOCK , PlayResult . WIN_PLAYER_ONE ); invokeAndCheckResult ( PlayMove . SPOCK , PlayMove . PAPER , PlayResult . WIN_PLAYER_TWO ); } RuleEngine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private boolean isPlayWinner ( PlayMove moveOne , PlayMove moveTwo ) { if ( moveOne . equals ( PlayMove . SCISSORS ) && ( moveTwo . equals ( PlayMove . PAPER ) || moveTwo . equals ( PlayMove . LIZARD ))) return true ; if ( moveOne . equals ( PlayMove . PAPER ) && ( moveTwo . equals ( PlayMove . ROCK ) || moveTwo . equals ( PlayMove . SPOCK ))) return true ; if ( moveOne . equals ( PlayMove . ROCK ) && moveTwo . equals ( PlayMove . LIZARD )) return true ; if ( moveOne . equals ( PlayMove . LIZARD ) && ( moveTwo . equals ( PlayMove . SPOCK ) || moveTwo . equals ( PlayMove . PAPER ))) return true ; if ( moveOne . equals ( PlayMove . SPOCK ) && moveTwo . equals ( PlayMove . SCISSORS )) return true ; return false ; } Otro requisito m\u00e1s, ya faltan menos.","title":"Desarrollo"}]}